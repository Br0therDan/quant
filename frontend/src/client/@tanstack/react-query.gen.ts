// This file is auto-generated by @hey-api/openapi-ts

import { queryOptions, type UseMutationOptions } from "@tanstack/react-query";

import { client } from "../client.gen";
import {
	AuthService,
	BacktestsService,
	DashboardService,
	HealthService,
	MarketDataEconomicService,
	MarketDataFundamentalService,
	MarketDataIntelligenceService,
	MarketDataManagementService,
	MarketDataService,
	MarketDataStockService,
	OAuth2Service,
	type Options,
	StrategyService,
	UserService,
	WatchlistsService,
} from "../sdk.gen";
import type {
	AuthForgotPasswordData,
	AuthForgotPasswordError,
	AuthLoginData,
	AuthLoginError,
	AuthLoginResponse,
	AuthLogoutData,
	AuthLogoutError,
	AuthLogoutResponse,
	AuthRefreshTokenData,
	AuthRefreshTokenError,
	AuthRefreshTokenResponse,
	AuthRegisterData,
	AuthRegisterError,
	AuthRegisterResponse,
	AuthRequestVerifyTokenData,
	AuthRequestVerifyTokenError,
	AuthResetPasswordData,
	AuthResetPasswordError,
	AuthVerifyData,
	AuthVerifyError,
	AuthVerifyResponse,
	AuthVerifyTokenData,
	BacktestsCreateAndRunIntegratedBacktestData,
	BacktestsCreateAndRunIntegratedBacktestError,
	BacktestsCreateAndRunIntegratedBacktestResponse,
	BacktestsCreateBacktestData,
	BacktestsCreateBacktestError,
	BacktestsCreateBacktestResponse,
	BacktestsDeleteBacktestData,
	BacktestsDeleteBacktestError,
	BacktestsExecuteBacktestData,
	BacktestsExecuteBacktestError,
	BacktestsExecuteBacktestResponse,
	BacktestsGetBacktestData,
	BacktestsGetBacktestExecutionsData,
	BacktestsGetBacktestResultsData,
	BacktestsGetBacktestsData,
	BacktestsGetBacktestSummaryAnalyticsData,
	BacktestsGetPerformanceAnalyticsData,
	BacktestsGetTradesAnalyticsData,
	BacktestsHealthCheckData,
	BacktestsUpdateBacktestData,
	BacktestsUpdateBacktestError,
	BacktestsUpdateBacktestResponse,
	DashboardGetDashboardSummaryData,
	DashboardGetEconomicCalendarData,
	DashboardGetNewsFeedData,
	DashboardGetPortfolioPerformanceData,
	DashboardGetRecentTradesData,
	DashboardGetStrategyComparisonData,
	DashboardGetWatchlistQuotesData,
	HealthHealthCheckData,
	HealthLivenessProbeData,
	HealthReadinessProbeData,
	MarketDataEconomicGetConsumerSentimentData,
	MarketDataEconomicGetEmploymentDataData,
	MarketDataEconomicGetGdpDataData,
	MarketDataEconomicGetInflationDataData,
	MarketDataEconomicGetInterestRatesData,
	MarketDataFundamentalGetBalanceSheetData,
	MarketDataFundamentalGetCashFlowData,
	MarketDataFundamentalGetCompanyOverviewData,
	MarketDataFundamentalGetEarningsData,
	MarketDataFundamentalGetIncomeStatementData,
	MarketDataGetMarketDataInfoData,
	MarketDataHealthCheckData,
	MarketDataIntelligenceGetAnalystRecommendationsData,
	MarketDataIntelligenceGetNewsData,
	MarketDataIntelligenceGetSentimentAnalysisData,
	MarketDataIntelligenceGetSocialSentimentData,
	MarketDataManagementCollectBulkDataData,
	MarketDataManagementCollectBulkDataError,
	MarketDataManagementCollectCompanyInfoData,
	MarketDataManagementCollectCompanyInfoError,
	MarketDataManagementCollectMarketDataData,
	MarketDataManagementCollectMarketDataError,
	MarketDataManagementGetDataCoverageData,
	MarketDataManagementGetSystemStatusData,
	MarketDataStockGetDailyPricesData,
	MarketDataStockGetHistoricalDataData,
	MarketDataStockGetIntradayDataData,
	MarketDataStockGetQuoteData,
	OAuth2AuthorizeData,
	OAuth2CallbackData,
	StrategyCreateStrategyData,
	StrategyCreateStrategyError,
	StrategyCreateStrategyFromTemplateData,
	StrategyCreateStrategyFromTemplateError,
	StrategyCreateStrategyFromTemplateResponse,
	StrategyCreateStrategyResponse,
	StrategyCreateTemplateData,
	StrategyCreateTemplateError,
	StrategyCreateTemplateResponse,
	StrategyDeleteStrategyData,
	StrategyDeleteStrategyError,
	StrategyDeleteTemplateData,
	StrategyDeleteTemplateError,
	StrategyExecuteStrategyData,
	StrategyExecuteStrategyError,
	StrategyExecuteStrategyResponse,
	StrategyGetStrategiesData,
	StrategyGetStrategyData,
	StrategyGetStrategyExecutionsData,
	StrategyGetStrategyPerformanceData,
	StrategyGetTemplateData,
	StrategyGetTemplatesData,
	StrategyGetTemplateUsageStatsData,
	StrategyUpdateStrategyData,
	StrategyUpdateStrategyError,
	StrategyUpdateStrategyResponse,
	StrategyUpdateTemplateData,
	StrategyUpdateTemplateError,
	StrategyUpdateTemplateResponse,
	UserDeleteUserData,
	UserDeleteUserError,
	UserDeleteUserResponse,
	UserGetMyOauthAccountsData,
	UserGetUserData,
	UserGetUserMeData,
	UserGetUserOauthAccountsData,
	UserRemoveOauthAccountData,
	UserRemoveOauthAccountError,
	UserRemoveOauthAccountResponse,
	UserUpdateUserData,
	UserUpdateUserError,
	UserUpdateUserMeData,
	UserUpdateUserMeError,
	UserUpdateUserMeResponse,
	UserUpdateUserResponse,
	WatchlistsCreateOrUpdateWatchlistData,
	WatchlistsCreateOrUpdateWatchlistError,
	WatchlistsCreateWatchlistData,
	WatchlistsCreateWatchlistError,
	WatchlistsDeleteWatchlistData,
	WatchlistsDeleteWatchlistError,
	WatchlistsGetWatchlistCoverageData,
	WatchlistsGetWatchlistData,
	WatchlistsListWatchlistsData,
	WatchlistsSetupDefaultWatchlistData,
	WatchlistsSetupDefaultWatchlistError,
	WatchlistsUpdateWatchlistData,
	WatchlistsUpdateWatchlistError,
} from "../types.gen";

export type QueryKey<TOptions extends Options> = [
	Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
		_id: string;
		_infinite?: boolean;
		tags?: ReadonlyArray<string>;
	},
];

const createQueryKey = <TOptions extends Options>(
	id: string,
	options?: TOptions,
	infinite?: boolean,
	tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
	const params: QueryKey<TOptions>[0] = {
		_id: id,
		baseUrl:
			options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
	} as QueryKey<TOptions>[0];
	if (infinite) {
		params._infinite = infinite;
	}
	if (tags) {
		params.tags = tags;
	}
	if (options?.body) {
		params.body = options.body;
	}
	if (options?.headers) {
		params.headers = options.headers;
	}
	if (options?.path) {
		params.path = options.path;
	}
	if (options?.query) {
		params.query = options.query;
	}
	return [params];
};

export const healthHealthCheckQueryKey = (
	options?: Options<HealthHealthCheckData>,
) => createQueryKey("healthHealthCheck", options);

/**
 * Health Check
 * Get comprehensive health status.
 */
export const healthHealthCheckOptions = (
	options?: Options<HealthHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.healthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthHealthCheckQueryKey(options),
	});
};

export const healthLivenessProbeQueryKey = (
	options?: Options<HealthLivenessProbeData>,
) => createQueryKey("healthLivenessProbe", options);

/**
 * Liveness Probe
 * Kubernetes liveness probe endpoint.
 */
export const healthLivenessProbeOptions = (
	options?: Options<HealthLivenessProbeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.livenessProbe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthLivenessProbeQueryKey(options),
	});
};

export const healthReadinessProbeQueryKey = (
	options?: Options<HealthReadinessProbeData>,
) => createQueryKey("healthReadinessProbe", options);

/**
 * Readiness Probe
 * Kubernetes readiness probe endpoint.
 */
export const healthReadinessProbeOptions = (
	options?: Options<HealthReadinessProbeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.readinessProbe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthReadinessProbeQueryKey(options),
	});
};

/**
 * Login
 */
export const authLoginMutation = (
	options?: Partial<Options<AuthLoginData>>,
): UseMutationOptions<
	AuthLoginResponse,
	AuthLoginError,
	Options<AuthLoginData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthLoginResponse,
		AuthLoginError,
		Options<AuthLoginData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.login({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Logout
 * 로그아웃 엔드포인트.
 *
 * 쿠키에서 토큰을 삭제하고 로그아웃 처리를 합니다.
 */
export const authLogoutMutation = (
	options?: Partial<Options<AuthLogoutData>>,
): UseMutationOptions<
	AuthLogoutResponse,
	AuthLogoutError,
	Options<AuthLogoutData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthLogoutResponse,
		AuthLogoutError,
		Options<AuthLogoutData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.logout({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Refresh Token
 * JWT 토큰 갱신 엔드포인트
 */
export const authRefreshTokenMutation = (
	options?: Partial<Options<AuthRefreshTokenData>>,
): UseMutationOptions<
	AuthRefreshTokenResponse,
	AuthRefreshTokenError,
	Options<AuthRefreshTokenData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthRefreshTokenResponse,
		AuthRefreshTokenError,
		Options<AuthRefreshTokenData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.refreshToken({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const authVerifyTokenQueryKey = (
	options?: Options<AuthVerifyTokenData>,
) => createQueryKey("authVerifyToken", options);

/**
 * Verify Token
 * 토큰 검증 및 사용자 정보 반환 (디버깅용)
 */
export const authVerifyTokenOptions = (
	options?: Options<AuthVerifyTokenData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await AuthService.verifyToken({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: authVerifyTokenQueryKey(options),
	});
};

/**
 * Register
 */
export const authRegisterMutation = (
	options?: Partial<Options<AuthRegisterData>>,
): UseMutationOptions<
	AuthRegisterResponse,
	AuthRegisterError,
	Options<AuthRegisterData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthRegisterResponse,
		AuthRegisterError,
		Options<AuthRegisterData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.register({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Forgot Password
 */
export const authForgotPasswordMutation = (
	options?: Partial<Options<AuthForgotPasswordData>>,
): UseMutationOptions<
	unknown,
	AuthForgotPasswordError,
	Options<AuthForgotPasswordData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthForgotPasswordError,
		Options<AuthForgotPasswordData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.forgotPassword({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Reset Password
 */
export const authResetPasswordMutation = (
	options?: Partial<Options<AuthResetPasswordData>>,
): UseMutationOptions<
	unknown,
	AuthResetPasswordError,
	Options<AuthResetPasswordData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthResetPasswordError,
		Options<AuthResetPasswordData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.resetPassword({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Request Verify Token
 */
export const authRequestVerifyTokenMutation = (
	options?: Partial<Options<AuthRequestVerifyTokenData>>,
): UseMutationOptions<
	unknown,
	AuthRequestVerifyTokenError,
	Options<AuthRequestVerifyTokenData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthRequestVerifyTokenError,
		Options<AuthRequestVerifyTokenData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.requestVerifyToken({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Verify
 */
export const authVerifyMutation = (
	options?: Partial<Options<AuthVerifyData>>,
): UseMutationOptions<
	AuthVerifyResponse,
	AuthVerifyError,
	Options<AuthVerifyData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthVerifyResponse,
		AuthVerifyError,
		Options<AuthVerifyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.verify({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserMeQueryKey = (options?: Options<UserGetUserMeData>) =>
	createQueryKey("userGetUserMe", options);

/**
 * Get User Me
 */
export const userGetUserMeOptions = (options?: Options<UserGetUserMeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getUserMe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserMeQueryKey(options),
	});
};

/**
 * Update User Me
 */
export const userUpdateUserMeMutation = (
	options?: Partial<Options<UserUpdateUserMeData>>,
): UseMutationOptions<
	UserUpdateUserMeResponse,
	UserUpdateUserMeError,
	Options<UserUpdateUserMeData>
> => {
	const mutationOptions: UseMutationOptions<
		UserUpdateUserMeResponse,
		UserUpdateUserMeError,
		Options<UserUpdateUserMeData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.updateUserMe({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete User
 */
export const userDeleteUserMutation = (
	options?: Partial<Options<UserDeleteUserData>>,
): UseMutationOptions<
	UserDeleteUserResponse,
	UserDeleteUserError,
	Options<UserDeleteUserData>
> => {
	const mutationOptions: UseMutationOptions<
		UserDeleteUserResponse,
		UserDeleteUserError,
		Options<UserDeleteUserData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.deleteUser({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserQueryKey = (options: Options<UserGetUserData>) =>
	createQueryKey("userGetUser", options);

/**
 * Get User
 */
export const userGetUserOptions = (options: Options<UserGetUserData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getUser({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserQueryKey(options),
	});
};

/**
 * Update User
 */
export const userUpdateUserMutation = (
	options?: Partial<Options<UserUpdateUserData>>,
): UseMutationOptions<
	UserUpdateUserResponse,
	UserUpdateUserError,
	Options<UserUpdateUserData>
> => {
	const mutationOptions: UseMutationOptions<
		UserUpdateUserResponse,
		UserUpdateUserError,
		Options<UserUpdateUserData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.updateUser({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const oAuth2AuthorizeQueryKey = (
	options: Options<OAuth2AuthorizeData>,
) => createQueryKey("oAuth2Authorize", options);

/**
 * Authorize
 * Initiate the OAuth2 authorization process for associating an OAuth account
 * with the currently authenticated user.
 */
export const oAuth2AuthorizeOptions = (
	options: Options<OAuth2AuthorizeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await OAuth2Service.authorize({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: oAuth2AuthorizeQueryKey(options),
	});
};

export const oAuth2CallbackQueryKey = (options: Options<OAuth2CallbackData>) =>
	createQueryKey("oAuth2Callback", options);

/**
 * Callback
 * The response varies based on the authentication backend used.
 */
export const oAuth2CallbackOptions = (options: Options<OAuth2CallbackData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await OAuth2Service.callback({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: oAuth2CallbackQueryKey(options),
	});
};

export const userGetMyOauthAccountsQueryKey = (
	options?: Options<UserGetMyOauthAccountsData>,
) => createQueryKey("userGetMyOauthAccounts", options);

/**
 * Get My Oauth Accounts
 * 현재 사용자의 연결된 OAuth 계정 목록을 조회합니다.
 */
export const userGetMyOauthAccountsOptions = (
	options?: Options<UserGetMyOauthAccountsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getMyOauthAccounts({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetMyOauthAccountsQueryKey(options),
	});
};

/**
 * Remove Oauth Account
 * 특정 OAuth 계정 연결을 해제합니다.
 */
export const userRemoveOauthAccountMutation = (
	options?: Partial<Options<UserRemoveOauthAccountData>>,
): UseMutationOptions<
	UserRemoveOauthAccountResponse,
	UserRemoveOauthAccountError,
	Options<UserRemoveOauthAccountData>
> => {
	const mutationOptions: UseMutationOptions<
		UserRemoveOauthAccountResponse,
		UserRemoveOauthAccountError,
		Options<UserRemoveOauthAccountData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.removeOauthAccount({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserOauthAccountsQueryKey = (
	options: Options<UserGetUserOauthAccountsData>,
) => createQueryKey("userGetUserOauthAccounts", options);

/**
 * Get User Oauth Accounts
 * 특정 사용자의 OAuth 계정 목록을 조회합니다. (관리자 전용)
 */
export const userGetUserOauthAccountsOptions = (
	options: Options<UserGetUserOauthAccountsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getUserOauthAccounts({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserOauthAccountsQueryKey(options),
	});
};

export const marketDataStockGetDailyPricesQueryKey = (
	options: Options<MarketDataStockGetDailyPricesData>,
) => createQueryKey("marketDataStockGetDailyPrices", options);

/**
 * Get Daily Prices
 * 지정된 종목의 일일 주가 데이터(OHLCV)를 조회합니다.
 */
export const marketDataStockGetDailyPricesOptions = (
	options: Options<MarketDataStockGetDailyPricesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataStockService.getDailyPrices({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataStockGetDailyPricesQueryKey(options),
	});
};

export const marketDataStockGetQuoteQueryKey = (
	options: Options<MarketDataStockGetQuoteData>,
) => createQueryKey("marketDataStockGetQuote", options);

/**
 * Get Quote
 * 지정된 종목의 실시간 호가 정보를 조회합니다.
 */
export const marketDataStockGetQuoteOptions = (
	options: Options<MarketDataStockGetQuoteData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataStockService.getQuote({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataStockGetQuoteQueryKey(options),
	});
};

export const marketDataStockGetIntradayDataQueryKey = (
	options: Options<MarketDataStockGetIntradayDataData>,
) => createQueryKey("marketDataStockGetIntradayData", options);

/**
 * Get Intraday Data
 * 지정된 종목의 실시간 또는 분봉 데이터를 조회합니다.
 */
export const marketDataStockGetIntradayDataOptions = (
	options: Options<MarketDataStockGetIntradayDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataStockService.getIntradayData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataStockGetIntradayDataQueryKey(options),
	});
};

export const marketDataStockGetHistoricalDataQueryKey = (
	options: Options<MarketDataStockGetHistoricalDataData>,
) => createQueryKey("marketDataStockGetHistoricalData", options);

/**
 * Get Historical Data
 * 지정된 종목의 장기 히스토리 데이터를 조회합니다.
 */
export const marketDataStockGetHistoricalDataOptions = (
	options: Options<MarketDataStockGetHistoricalDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataStockService.getHistoricalData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataStockGetHistoricalDataQueryKey(options),
	});
};

export const marketDataFundamentalGetCompanyOverviewQueryKey = (
	options: Options<MarketDataFundamentalGetCompanyOverviewData>,
) => createQueryKey("marketDataFundamentalGetCompanyOverview", options);

/**
 * Get Company Overview
 * 지정된 종목의 기업 개요 정보를 조회합니다.
 */
export const marketDataFundamentalGetCompanyOverviewOptions = (
	options: Options<MarketDataFundamentalGetCompanyOverviewData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataFundamentalService.getCompanyOverview({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataFundamentalGetCompanyOverviewQueryKey(options),
	});
};

export const marketDataFundamentalGetIncomeStatementQueryKey = (
	options: Options<MarketDataFundamentalGetIncomeStatementData>,
) => createQueryKey("marketDataFundamentalGetIncomeStatement", options);

/**
 * Get Income Statement
 * 지정된 종목의 손익계산서를 조회합니다.
 */
export const marketDataFundamentalGetIncomeStatementOptions = (
	options: Options<MarketDataFundamentalGetIncomeStatementData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataFundamentalService.getIncomeStatement({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataFundamentalGetIncomeStatementQueryKey(options),
	});
};

export const marketDataFundamentalGetBalanceSheetQueryKey = (
	options: Options<MarketDataFundamentalGetBalanceSheetData>,
) => createQueryKey("marketDataFundamentalGetBalanceSheet", options);

/**
 * Get Balance Sheet
 * 지정된 종목의 재무상태표를 조회합니다.
 */
export const marketDataFundamentalGetBalanceSheetOptions = (
	options: Options<MarketDataFundamentalGetBalanceSheetData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataFundamentalService.getBalanceSheet({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataFundamentalGetBalanceSheetQueryKey(options),
	});
};

export const marketDataFundamentalGetCashFlowQueryKey = (
	options: Options<MarketDataFundamentalGetCashFlowData>,
) => createQueryKey("marketDataFundamentalGetCashFlow", options);

/**
 * Get Cash Flow
 * 지정된 종목의 현금흐름표를 조회합니다.
 */
export const marketDataFundamentalGetCashFlowOptions = (
	options: Options<MarketDataFundamentalGetCashFlowData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataFundamentalService.getCashFlow({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataFundamentalGetCashFlowQueryKey(options),
	});
};

export const marketDataFundamentalGetEarningsQueryKey = (
	options: Options<MarketDataFundamentalGetEarningsData>,
) => createQueryKey("marketDataFundamentalGetEarnings", options);

/**
 * Get Earnings
 * 지정된 종목의 실적 데이터를 조회합니다.
 */
export const marketDataFundamentalGetEarningsOptions = (
	options: Options<MarketDataFundamentalGetEarningsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataFundamentalService.getEarnings({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataFundamentalGetEarningsQueryKey(options),
	});
};

export const marketDataEconomicGetGdpDataQueryKey = (
	options?: Options<MarketDataEconomicGetGdpDataData>,
) => createQueryKey("marketDataEconomicGetGdpData", options);

/**
 * Get Gdp Data
 * 미국 GDP 데이터를 조회합니다.
 */
export const marketDataEconomicGetGdpDataOptions = (
	options?: Options<MarketDataEconomicGetGdpDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataEconomicService.getGdpData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataEconomicGetGdpDataQueryKey(options),
	});
};

export const marketDataEconomicGetInflationDataQueryKey = (
	options?: Options<MarketDataEconomicGetInflationDataData>,
) => createQueryKey("marketDataEconomicGetInflationData", options);

/**
 * Get Inflation Data
 * 미국 인플레이션 지표 데이터를 조회합니다.
 */
export const marketDataEconomicGetInflationDataOptions = (
	options?: Options<MarketDataEconomicGetInflationDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataEconomicService.getInflationData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataEconomicGetInflationDataQueryKey(options),
	});
};

export const marketDataEconomicGetInterestRatesQueryKey = (
	options?: Options<MarketDataEconomicGetInterestRatesData>,
) => createQueryKey("marketDataEconomicGetInterestRates", options);

/**
 * Get Interest Rates
 * 미국 기준금리 및 채권 수익률 데이터를 조회합니다.
 */
export const marketDataEconomicGetInterestRatesOptions = (
	options?: Options<MarketDataEconomicGetInterestRatesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataEconomicService.getInterestRates({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataEconomicGetInterestRatesQueryKey(options),
	});
};

export const marketDataEconomicGetEmploymentDataQueryKey = (
	options?: Options<MarketDataEconomicGetEmploymentDataData>,
) => createQueryKey("marketDataEconomicGetEmploymentData", options);

/**
 * Get Employment Data
 * 미국 실업률 및 고용 관련 지표를 조회합니다.
 */
export const marketDataEconomicGetEmploymentDataOptions = (
	options?: Options<MarketDataEconomicGetEmploymentDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataEconomicService.getEmploymentData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataEconomicGetEmploymentDataQueryKey(options),
	});
};

export const marketDataEconomicGetConsumerSentimentQueryKey = (
	options?: Options<MarketDataEconomicGetConsumerSentimentData>,
) => createQueryKey("marketDataEconomicGetConsumerSentiment", options);

/**
 * Get Consumer Sentiment
 * 미국 소비자 심리 지수를 조회합니다.
 */
export const marketDataEconomicGetConsumerSentimentOptions = (
	options?: Options<MarketDataEconomicGetConsumerSentimentData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataEconomicService.getConsumerSentiment({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataEconomicGetConsumerSentimentQueryKey(options),
	});
};

export const marketDataIntelligenceGetNewsQueryKey = (
	options: Options<MarketDataIntelligenceGetNewsData>,
) => createQueryKey("marketDataIntelligenceGetNews", options);

/**
 * Get News
 * 지정된 종목 관련 뉴스를 조회합니다.
 */
export const marketDataIntelligenceGetNewsOptions = (
	options: Options<MarketDataIntelligenceGetNewsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataIntelligenceService.getNews({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataIntelligenceGetNewsQueryKey(options),
	});
};

export const marketDataIntelligenceGetSentimentAnalysisQueryKey = (
	options: Options<MarketDataIntelligenceGetSentimentAnalysisData>,
) => createQueryKey("marketDataIntelligenceGetSentimentAnalysis", options);

/**
 * Get Sentiment Analysis
 * 지정된 종목의 감정 분석 결과를 조회합니다.
 */
export const marketDataIntelligenceGetSentimentAnalysisOptions = (
	options: Options<MarketDataIntelligenceGetSentimentAnalysisData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataIntelligenceService.getSentimentAnalysis(
				{
					...options,
					...queryKey[0],
					signal,
					throwOnError: true,
				},
			);
			return data;
		},
		queryKey: marketDataIntelligenceGetSentimentAnalysisQueryKey(options),
	});
};

export const marketDataIntelligenceGetAnalystRecommendationsQueryKey = (
	options: Options<MarketDataIntelligenceGetAnalystRecommendationsData>,
) => createQueryKey("marketDataIntelligenceGetAnalystRecommendations", options);

/**
 * Get Analyst Recommendations
 * 지정된 종목의 분석가 추천 정보를 조회합니다.
 */
export const marketDataIntelligenceGetAnalystRecommendationsOptions = (
	options: Options<MarketDataIntelligenceGetAnalystRecommendationsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } =
				await MarketDataIntelligenceService.getAnalystRecommendations({
					...options,
					...queryKey[0],
					signal,
					throwOnError: true,
				});
			return data;
		},
		queryKey: marketDataIntelligenceGetAnalystRecommendationsQueryKey(options),
	});
};

export const marketDataIntelligenceGetSocialSentimentQueryKey = (
	options: Options<MarketDataIntelligenceGetSocialSentimentData>,
) => createQueryKey("marketDataIntelligenceGetSocialSentiment", options);

/**
 * Get Social Sentiment
 * 지정된 종목의 소셜 미디어 감정 분석을 조회합니다.
 */
export const marketDataIntelligenceGetSocialSentimentOptions = (
	options: Options<MarketDataIntelligenceGetSocialSentimentData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataIntelligenceService.getSocialSentiment({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataIntelligenceGetSocialSentimentQueryKey(options),
	});
};

/**
 * Collect Company Info
 * 지정된 심볼의 기업 정보를 수집하여 저장
 *
 * Alpha Vantage API를 통해 기업의 기본 정보, 재무 지표,
 * 업종 분류 등을 수집하고 데이터베이스에 저장합니다.
 */
export const marketDataManagementCollectCompanyInfoMutation = (
	options?: Partial<Options<MarketDataManagementCollectCompanyInfoData>>,
): UseMutationOptions<
	unknown,
	MarketDataManagementCollectCompanyInfoError,
	Options<MarketDataManagementCollectCompanyInfoData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		MarketDataManagementCollectCompanyInfoError,
		Options<MarketDataManagementCollectCompanyInfoData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await MarketDataManagementService.collectCompanyInfo({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Collect Market Data
 * 지정된 심볼의 주가 데이터를 수집하여 저장
 *
 * Alpha Vantage API를 통해 일일 OHLCV 데이터를 수집하고
 * DuckDB 캐시 및 MongoDB에 저장합니다.
 */
export const marketDataManagementCollectMarketDataMutation = (
	options?: Partial<Options<MarketDataManagementCollectMarketDataData>>,
): UseMutationOptions<
	unknown,
	MarketDataManagementCollectMarketDataError,
	Options<MarketDataManagementCollectMarketDataData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		MarketDataManagementCollectMarketDataError,
		Options<MarketDataManagementCollectMarketDataData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await MarketDataManagementService.collectMarketData({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Collect Bulk Data
 * 여러 심볼의 데이터를 일괄 수집
 *
 * 백그라운드 작업으로 처리되며, 대량의 심볼에 대해
 * 기업 정보와 주가 데이터를 순차적으로 수집합니다.
 */
export const marketDataManagementCollectBulkDataMutation = (
	options?: Partial<Options<MarketDataManagementCollectBulkDataData>>,
): UseMutationOptions<
	unknown,
	MarketDataManagementCollectBulkDataError,
	Options<MarketDataManagementCollectBulkDataData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		MarketDataManagementCollectBulkDataError,
		Options<MarketDataManagementCollectBulkDataData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await MarketDataManagementService.collectBulkData({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const marketDataManagementGetDataCoverageQueryKey = (
	options: Options<MarketDataManagementGetDataCoverageData>,
) => createQueryKey("marketDataManagementGetDataCoverage", options);

/**
 * Get Data Coverage
 * 지정된 심볼의 데이터 커버리지 정보 조회
 *
 * 기업 정보, 주가 데이터의 수집 상태와 품질을 확인합니다.
 */
export const marketDataManagementGetDataCoverageOptions = (
	options: Options<MarketDataManagementGetDataCoverageData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataManagementService.getDataCoverage({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataManagementGetDataCoverageQueryKey(options),
	});
};

export const marketDataManagementGetSystemStatusQueryKey = (
	options?: Options<MarketDataManagementGetSystemStatusData>,
) => createQueryKey("marketDataManagementGetSystemStatus", options);

/**
 * Get System Status
 * 시장 데이터 시스템의 전반적인 상태 조회
 *
 * API 연결 상태, 캐시 성능, 수집 통계 등을 확인합니다.
 */
export const marketDataManagementGetSystemStatusOptions = (
	options?: Options<MarketDataManagementGetSystemStatusData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataManagementService.getSystemStatus({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataManagementGetSystemStatusQueryKey(options),
	});
};

export const marketDataGetMarketDataInfoQueryKey = (
	options?: Options<MarketDataGetMarketDataInfoData>,
) => createQueryKey("marketDataGetMarketDataInfo", options);

/**
 * Get Market Data Info
 * 마켓 데이터 API 정보 및 사용 가능한 엔드포인트 목록
 */
export const marketDataGetMarketDataInfoOptions = (
	options?: Options<MarketDataGetMarketDataInfoData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getMarketDataInfo({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetMarketDataInfoQueryKey(options),
	});
};

export const marketDataHealthCheckQueryKey = (
	options?: Options<MarketDataHealthCheckData>,
) => createQueryKey("marketDataHealthCheck", options);

/**
 * Health Check
 * 마켓 데이터 서비스 상태 확인
 */
export const marketDataHealthCheckOptions = (
	options?: Options<MarketDataHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.healthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataHealthCheckQueryKey(options),
	});
};

export const strategyGetStrategiesQueryKey = (
	options?: Options<StrategyGetStrategiesData>,
) => createQueryKey("strategyGetStrategies", options);

/**
 * Get Strategies
 * Get list of strategies
 */
export const strategyGetStrategiesOptions = (
	options?: Options<StrategyGetStrategiesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategies({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategiesQueryKey(options),
	});
};

/**
 * Create Strategy
 * Create a new strategy
 */
export const strategyCreateStrategyMutation = (
	options?: Partial<Options<StrategyCreateStrategyData>>,
): UseMutationOptions<
	StrategyCreateStrategyResponse,
	StrategyCreateStrategyError,
	Options<StrategyCreateStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateStrategyResponse,
		StrategyCreateStrategyError,
		Options<StrategyCreateStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.createStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Strategy
 * Delete strategy (soft delete)
 */
export const strategyDeleteStrategyMutation = (
	options?: Partial<Options<StrategyDeleteStrategyData>>,
): UseMutationOptions<
	unknown,
	StrategyDeleteStrategyError,
	Options<StrategyDeleteStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		StrategyDeleteStrategyError,
		Options<StrategyDeleteStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.deleteStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetStrategyQueryKey = (
	options: Options<StrategyGetStrategyData>,
) => createQueryKey("strategyGetStrategy", options);

/**
 * Get Strategy
 * Get strategy by ID
 */
export const strategyGetStrategyOptions = (
	options: Options<StrategyGetStrategyData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategy({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyQueryKey(options),
	});
};

/**
 * Update Strategy
 * Update strategy
 */
export const strategyUpdateStrategyMutation = (
	options?: Partial<Options<StrategyUpdateStrategyData>>,
): UseMutationOptions<
	StrategyUpdateStrategyResponse,
	StrategyUpdateStrategyError,
	Options<StrategyUpdateStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyUpdateStrategyResponse,
		StrategyUpdateStrategyError,
		Options<StrategyUpdateStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.updateStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Execute Strategy
 * Execute strategy and generate signal
 */
export const strategyExecuteStrategyMutation = (
	options?: Partial<Options<StrategyExecuteStrategyData>>,
): UseMutationOptions<
	StrategyExecuteStrategyResponse,
	StrategyExecuteStrategyError,
	Options<StrategyExecuteStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyExecuteStrategyResponse,
		StrategyExecuteStrategyError,
		Options<StrategyExecuteStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.executeStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetStrategyExecutionsQueryKey = (
	options: Options<StrategyGetStrategyExecutionsData>,
) => createQueryKey("strategyGetStrategyExecutions", options);

/**
 * Get Strategy Executions
 * Get strategy execution history
 */
export const strategyGetStrategyExecutionsOptions = (
	options: Options<StrategyGetStrategyExecutionsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategyExecutions({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyExecutionsQueryKey(options),
	});
};

export const strategyGetStrategyPerformanceQueryKey = (
	options: Options<StrategyGetStrategyPerformanceData>,
) => createQueryKey("strategyGetStrategyPerformance", options);

/**
 * Get Strategy Performance
 * Get strategy performance metrics
 */
export const strategyGetStrategyPerformanceOptions = (
	options: Options<StrategyGetStrategyPerformanceData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategyPerformance({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyPerformanceQueryKey(options),
	});
};

export const strategyGetTemplatesQueryKey = (
	options?: Options<StrategyGetTemplatesData>,
) => createQueryKey("strategyGetTemplates", options);

/**
 * Get Templates
 * Get list of strategy templates
 */
export const strategyGetTemplatesOptions = (
	options?: Options<StrategyGetTemplatesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getTemplates({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplatesQueryKey(options),
	});
};

/**
 * Create Template
 * Create a new strategy template (Superuser only)
 */
export const strategyCreateTemplateMutation = (
	options?: Partial<Options<StrategyCreateTemplateData>>,
): UseMutationOptions<
	StrategyCreateTemplateResponse,
	StrategyCreateTemplateError,
	Options<StrategyCreateTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateTemplateResponse,
		StrategyCreateTemplateError,
		Options<StrategyCreateTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.createTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Template
 * Delete template by ID (Superuser only)
 */
export const strategyDeleteTemplateMutation = (
	options?: Partial<Options<StrategyDeleteTemplateData>>,
): UseMutationOptions<
	unknown,
	StrategyDeleteTemplateError,
	Options<StrategyDeleteTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		StrategyDeleteTemplateError,
		Options<StrategyDeleteTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.deleteTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetTemplateQueryKey = (
	options: Options<StrategyGetTemplateData>,
) => createQueryKey("strategyGetTemplate", options);

/**
 * Get Template
 * Get template by ID
 */
export const strategyGetTemplateOptions = (
	options: Options<StrategyGetTemplateData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getTemplate({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplateQueryKey(options),
	});
};

/**
 * Update Template
 * Update template by ID (Superuser only)
 */
export const strategyUpdateTemplateMutation = (
	options?: Partial<Options<StrategyUpdateTemplateData>>,
): UseMutationOptions<
	StrategyUpdateTemplateResponse,
	StrategyUpdateTemplateError,
	Options<StrategyUpdateTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyUpdateTemplateResponse,
		StrategyUpdateTemplateError,
		Options<StrategyUpdateTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.updateTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Create Strategy From Template
 * Create a strategy instance from template
 */
export const strategyCreateStrategyFromTemplateMutation = (
	options?: Partial<Options<StrategyCreateStrategyFromTemplateData>>,
): UseMutationOptions<
	StrategyCreateStrategyFromTemplateResponse,
	StrategyCreateStrategyFromTemplateError,
	Options<StrategyCreateStrategyFromTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateStrategyFromTemplateResponse,
		StrategyCreateStrategyFromTemplateError,
		Options<StrategyCreateStrategyFromTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.createStrategyFromTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetTemplateUsageStatsQueryKey = (
	options?: Options<StrategyGetTemplateUsageStatsData>,
) => createQueryKey("strategyGetTemplateUsageStats", options);

/**
 * Get Template Usage Stats
 * Get template usage statistics
 */
export const strategyGetTemplateUsageStatsOptions = (
	options?: Options<StrategyGetTemplateUsageStatsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getTemplateUsageStats({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplateUsageStatsQueryKey(options),
	});
};

export const backtestsGetBacktestsQueryKey = (
	options?: Options<BacktestsGetBacktestsData>,
) => createQueryKey("backtestsGetBacktests", options);

/**
 * Get Backtests
 * Get list of backtests
 */
export const backtestsGetBacktestsOptions = (
	options?: Options<BacktestsGetBacktestsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktests({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestsQueryKey(options),
	});
};

/**
 * Create Backtest
 * Create a new backtest
 */
export const backtestsCreateBacktestMutation = (
	options?: Partial<Options<BacktestsCreateBacktestData>>,
): UseMutationOptions<
	BacktestsCreateBacktestResponse,
	BacktestsCreateBacktestError,
	Options<BacktestsCreateBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsCreateBacktestResponse,
		BacktestsCreateBacktestError,
		Options<BacktestsCreateBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.createBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Backtest
 * Delete backtest
 */
export const backtestsDeleteBacktestMutation = (
	options?: Partial<Options<BacktestsDeleteBacktestData>>,
): UseMutationOptions<
	unknown,
	BacktestsDeleteBacktestError,
	Options<BacktestsDeleteBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		BacktestsDeleteBacktestError,
		Options<BacktestsDeleteBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.deleteBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsGetBacktestQueryKey = (
	options: Options<BacktestsGetBacktestData>,
) => createQueryKey("backtestsGetBacktest", options);

/**
 * Get Backtest
 * Get backtest by ID
 */
export const backtestsGetBacktestOptions = (
	options: Options<BacktestsGetBacktestData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktest({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestQueryKey(options),
	});
};

/**
 * Update Backtest
 * Update backtest
 */
export const backtestsUpdateBacktestMutation = (
	options?: Partial<Options<BacktestsUpdateBacktestData>>,
): UseMutationOptions<
	BacktestsUpdateBacktestResponse,
	BacktestsUpdateBacktestError,
	Options<BacktestsUpdateBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsUpdateBacktestResponse,
		BacktestsUpdateBacktestError,
		Options<BacktestsUpdateBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.updateBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Execute Backtest
 * Execute backtest with trading signals
 */
export const backtestsExecuteBacktestMutation = (
	options?: Partial<Options<BacktestsExecuteBacktestData>>,
): UseMutationOptions<
	BacktestsExecuteBacktestResponse,
	BacktestsExecuteBacktestError,
	Options<BacktestsExecuteBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsExecuteBacktestResponse,
		BacktestsExecuteBacktestError,
		Options<BacktestsExecuteBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.executeBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsGetBacktestExecutionsQueryKey = (
	options: Options<BacktestsGetBacktestExecutionsData>,
) => createQueryKey("backtestsGetBacktestExecutions", options);

/**
 * Get Backtest Executions
 * Get execution history for a backtest
 */
export const backtestsGetBacktestExecutionsOptions = (
	options: Options<BacktestsGetBacktestExecutionsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktestExecutions({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestExecutionsQueryKey(options),
	});
};

export const backtestsGetBacktestResultsQueryKey = (
	options?: Options<BacktestsGetBacktestResultsData>,
) => createQueryKey("backtestsGetBacktestResults", options);

/**
 * Get Backtest Results
 * Get backtest results from DuckDB (고성능 분석용)
 */
export const backtestsGetBacktestResultsOptions = (
	options?: Options<BacktestsGetBacktestResultsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktestResults({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestResultsQueryKey(options),
	});
};

/**
 * Create And Run Integrated Backtest
 * 통합 백테스트 생성 및 실행 - 모든 서비스 연동
 */
export const backtestsCreateAndRunIntegratedBacktestMutation = (
	options?: Partial<Options<BacktestsCreateAndRunIntegratedBacktestData>>,
): UseMutationOptions<
	BacktestsCreateAndRunIntegratedBacktestResponse,
	BacktestsCreateAndRunIntegratedBacktestError,
	Options<BacktestsCreateAndRunIntegratedBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsCreateAndRunIntegratedBacktestResponse,
		BacktestsCreateAndRunIntegratedBacktestError,
		Options<BacktestsCreateAndRunIntegratedBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.createAndRunIntegratedBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsHealthCheckQueryKey = (
	options?: Options<BacktestsHealthCheckData>,
) => createQueryKey("backtestsHealthCheck", options);

/**
 * Health Check
 * 백테스트 시스템 상태 확인 (DuckDB + MongoDB 통합 상태)
 */
export const backtestsHealthCheckOptions = (
	options?: Options<BacktestsHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.healthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsHealthCheckQueryKey(options),
	});
};

export const backtestsGetPerformanceAnalyticsQueryKey = (
	options?: Options<BacktestsGetPerformanceAnalyticsData>,
) => createQueryKey("backtestsGetPerformanceAnalytics", options);

/**
 * Get Performance Analytics
 * 백테스트 성과 분석 (DuckDB 고성능 분석)
 */
export const backtestsGetPerformanceAnalyticsOptions = (
	options?: Options<BacktestsGetPerformanceAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getPerformanceAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetPerformanceAnalyticsQueryKey(options),
	});
};

export const backtestsGetTradesAnalyticsQueryKey = (
	options?: Options<BacktestsGetTradesAnalyticsData>,
) => createQueryKey("backtestsGetTradesAnalytics", options);

/**
 * Get Trades Analytics
 * 거래 기록 분석 (DuckDB 고성능 쿼리)
 */
export const backtestsGetTradesAnalyticsOptions = (
	options?: Options<BacktestsGetTradesAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getTradesAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetTradesAnalyticsQueryKey(options),
	});
};

export const backtestsGetBacktestSummaryAnalyticsQueryKey = (
	options?: Options<BacktestsGetBacktestSummaryAnalyticsData>,
) => createQueryKey("backtestsGetBacktestSummaryAnalytics", options);

/**
 * Get Backtest Summary Analytics
 * 백테스트 결과 요약 분석 (DuckDB 기반)
 */
export const backtestsGetBacktestSummaryAnalyticsOptions = (
	options?: Options<BacktestsGetBacktestSummaryAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktestSummaryAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestSummaryAnalyticsQueryKey(options),
	});
};

export const watchlistsListWatchlistsQueryKey = (
	options?: Options<WatchlistsListWatchlistsData>,
) => createQueryKey("watchlistsListWatchlists", options);

/**
 * List Watchlists
 * 사용자의 모든 워치리스트 목록 조회
 *
 * 사용자에게 속한 모든 워치리스트의 요약 정보를 반환합니다.
 */
export const watchlistsListWatchlistsOptions = (
	options?: Options<WatchlistsListWatchlistsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await WatchlistsService.listWatchlists({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: watchlistsListWatchlistsQueryKey(options),
	});
};

/**
 * Create Or Update Watchlist
 * 워치리스트 생성 또는 업데이트
 *
 * 유연한 워치리스트 관리를 위한 엔드포인트입니다.
 * - 이름이 없으면 'default' 워치리스트로 처리
 * - 기존 워치리스트가 있으면 업데이트, 없으면 생성
 * - 심볼 데이터는 백그라운드에서 자동 수집
 */
export const watchlistsCreateOrUpdateWatchlistMutation = (
	options?: Partial<Options<WatchlistsCreateOrUpdateWatchlistData>>,
): UseMutationOptions<
	unknown,
	WatchlistsCreateOrUpdateWatchlistError,
	Options<WatchlistsCreateOrUpdateWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		WatchlistsCreateOrUpdateWatchlistError,
		Options<WatchlistsCreateOrUpdateWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await WatchlistsService.createOrUpdateWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Create Watchlist
 * 새로운 명명된 워치리스트 생성
 *
 * 명시적인 이름을 가진 새 워치리스트를 생성합니다.
 * 동일한 이름의 워치리스트가 이미 있으면 실패합니다.
 */
export const watchlistsCreateWatchlistMutation = (
	options?: Partial<Options<WatchlistsCreateWatchlistData>>,
): UseMutationOptions<
	unknown,
	WatchlistsCreateWatchlistError,
	Options<WatchlistsCreateWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		WatchlistsCreateWatchlistError,
		Options<WatchlistsCreateWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await WatchlistsService.createWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Watchlist
 * 워치리스트 삭제
 */
export const watchlistsDeleteWatchlistMutation = (
	options?: Partial<Options<WatchlistsDeleteWatchlistData>>,
): UseMutationOptions<
	unknown,
	WatchlistsDeleteWatchlistError,
	Options<WatchlistsDeleteWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		WatchlistsDeleteWatchlistError,
		Options<WatchlistsDeleteWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await WatchlistsService.deleteWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const watchlistsGetWatchlistQueryKey = (
	options: Options<WatchlistsGetWatchlistData>,
) => createQueryKey("watchlistsGetWatchlist", options);

/**
 * Get Watchlist
 * 특정 워치리스트의 상세 정보 조회
 */
export const watchlistsGetWatchlistOptions = (
	options: Options<WatchlistsGetWatchlistData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await WatchlistsService.getWatchlist({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: watchlistsGetWatchlistQueryKey(options),
	});
};

/**
 * Update Watchlist
 * 기존 워치리스트 업데이트
 */
export const watchlistsUpdateWatchlistMutation = (
	options?: Partial<Options<WatchlistsUpdateWatchlistData>>,
): UseMutationOptions<
	unknown,
	WatchlistsUpdateWatchlistError,
	Options<WatchlistsUpdateWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		WatchlistsUpdateWatchlistError,
		Options<WatchlistsUpdateWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await WatchlistsService.updateWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const watchlistsGetWatchlistCoverageQueryKey = (
	options: Options<WatchlistsGetWatchlistCoverageData>,
) => createQueryKey("watchlistsGetWatchlistCoverage", options);

/**
 * Get Watchlist Coverage
 * 워치리스트의 데이터 커버리지 정보 조회
 *
 * 각 심볼별로 수집된 데이터의 상태와 품질을 확인합니다.
 */
export const watchlistsGetWatchlistCoverageOptions = (
	options: Options<WatchlistsGetWatchlistCoverageData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await WatchlistsService.getWatchlistCoverage({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: watchlistsGetWatchlistCoverageQueryKey(options),
	});
};

/**
 * Setup Default Watchlist
 * 기본 워치리스트 설정
 *
 * 인기 주식들로 구성된 기본 워치리스트를 생성합니다.
 */
export const watchlistsSetupDefaultWatchlistMutation = (
	options?: Partial<Options<WatchlistsSetupDefaultWatchlistData>>,
): UseMutationOptions<
	unknown,
	WatchlistsSetupDefaultWatchlistError,
	Options<WatchlistsSetupDefaultWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		WatchlistsSetupDefaultWatchlistError,
		Options<WatchlistsSetupDefaultWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await WatchlistsService.setupDefaultWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const dashboardGetDashboardSummaryQueryKey = (
	options?: Options<DashboardGetDashboardSummaryData>,
) => createQueryKey("dashboardGetDashboardSummary", options);

/**
 * Get Dashboard Summary
 * 대시보드 요약 데이터를 조회합니다.
 *
 * 사용자의 포트폴리오, 전략, 최근 활동 요약 정보를 반환합니다.
 */
export const dashboardGetDashboardSummaryOptions = (
	options?: Options<DashboardGetDashboardSummaryData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await DashboardService.getDashboardSummary({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: dashboardGetDashboardSummaryQueryKey(options),
	});
};

export const dashboardGetPortfolioPerformanceQueryKey = (
	options?: Options<DashboardGetPortfolioPerformanceData>,
) => createQueryKey("dashboardGetPortfolioPerformance", options);

/**
 * Get Portfolio Performance
 * 포트폴리오 성과 차트 데이터를 조회합니다.
 *
 * 지정된 기간의 포트폴리오 성과 데이터와 요약 지표를 반환합니다.
 */
export const dashboardGetPortfolioPerformanceOptions = (
	options?: Options<DashboardGetPortfolioPerformanceData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await DashboardService.getPortfolioPerformance({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: dashboardGetPortfolioPerformanceQueryKey(options),
	});
};

export const dashboardGetStrategyComparisonQueryKey = (
	options?: Options<DashboardGetStrategyComparisonData>,
) => createQueryKey("dashboardGetStrategyComparison", options);

/**
 * Get Strategy Comparison
 * 전략 성과 비교 데이터를 조회합니다.
 *
 * 사용자의 전략들을 성과별로 비교한 데이터를 반환합니다.
 */
export const dashboardGetStrategyComparisonOptions = (
	options?: Options<DashboardGetStrategyComparisonData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await DashboardService.getStrategyComparison({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: dashboardGetStrategyComparisonQueryKey(options),
	});
};

export const dashboardGetRecentTradesQueryKey = (
	options?: Options<DashboardGetRecentTradesData>,
) => createQueryKey("dashboardGetRecentTrades", options);

/**
 * Get Recent Trades
 * 최근 거래 내역을 조회합니다.
 *
 * 지정된 기간의 최근 거래 내역과 요약 정보를 반환합니다.
 */
export const dashboardGetRecentTradesOptions = (
	options?: Options<DashboardGetRecentTradesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await DashboardService.getRecentTrades({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: dashboardGetRecentTradesQueryKey(options),
	});
};

export const dashboardGetWatchlistQuotesQueryKey = (
	options?: Options<DashboardGetWatchlistQuotesData>,
) => createQueryKey("dashboardGetWatchlistQuotes", options);

/**
 * Get Watchlist Quotes
 * 관심종목 현재가를 조회합니다.
 *
 * 사용자의 관심종목의 현재 주가 정보를 반환합니다.
 */
export const dashboardGetWatchlistQuotesOptions = (
	options?: Options<DashboardGetWatchlistQuotesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await DashboardService.getWatchlistQuotes({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: dashboardGetWatchlistQuotesQueryKey(options),
	});
};

export const dashboardGetNewsFeedQueryKey = (
	options?: Options<DashboardGetNewsFeedData>,
) => createQueryKey("dashboardGetNewsFeed", options);

/**
 * Get News Feed
 * 뉴스 피드를 조회합니다.
 *
 * 사용자와 관련된 뉴스 피드를 반환합니다.
 */
export const dashboardGetNewsFeedOptions = (
	options?: Options<DashboardGetNewsFeedData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await DashboardService.getNewsFeed({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: dashboardGetNewsFeedQueryKey(options),
	});
};

export const dashboardGetEconomicCalendarQueryKey = (
	options?: Options<DashboardGetEconomicCalendarData>,
) => createQueryKey("dashboardGetEconomicCalendar", options);

/**
 * Get Economic Calendar
 * 경제 캘린더를 조회합니다.
 *
 * 예정된 경제 지표 발표 일정을 반환합니다.
 */
export const dashboardGetEconomicCalendarOptions = (
	options?: Options<DashboardGetEconomicCalendarData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await DashboardService.getEconomicCalendar({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: dashboardGetEconomicCalendarQueryKey(options),
	});
};
