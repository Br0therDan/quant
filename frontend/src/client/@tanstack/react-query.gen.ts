// This file is auto-generated by @hey-api/openapi-ts

import { queryOptions, type UseMutationOptions } from "@tanstack/react-query";

import { client } from "../client.gen";
import {
	AuthService,
	BacktestsService,
	HealthService,
	MarketDataV2Service,
	OAuth2Service,
	type Options,
	PipelineService,
	StrategyService,
	UserService,
} from "../sdk.gen";
import type {
	AuthForgotPasswordData,
	AuthForgotPasswordError,
	AuthLoginData,
	AuthLoginError,
	AuthLoginResponse,
	AuthLogoutData,
	AuthLogoutError,
	AuthLogoutResponse,
	AuthRefreshTokenData,
	AuthRefreshTokenError,
	AuthRefreshTokenResponse,
	AuthRegisterData,
	AuthRegisterError,
	AuthRegisterResponse,
	AuthRequestVerifyTokenData,
	AuthRequestVerifyTokenError,
	AuthResetPasswordData,
	AuthResetPasswordError,
	AuthVerifyData,
	AuthVerifyError,
	AuthVerifyResponse,
	AuthVerifyTokenData,
	BacktestsCreateAndRunIntegratedBacktestData,
	BacktestsCreateAndRunIntegratedBacktestError,
	BacktestsCreateAndRunIntegratedBacktestResponse,
	BacktestsCreateBacktestData,
	BacktestsCreateBacktestError,
	BacktestsCreateBacktestResponse,
	BacktestsDeleteBacktestData,
	BacktestsDeleteBacktestError,
	BacktestsExecuteBacktestData,
	BacktestsExecuteBacktestError,
	BacktestsExecuteBacktestResponse,
	BacktestsGetBacktestData,
	BacktestsGetBacktestExecutionsData,
	BacktestsGetBacktestResultsData,
	BacktestsGetBacktestsData,
	BacktestsGetBacktestSummaryAnalyticsData,
	BacktestsGetPerformanceAnalyticsData,
	BacktestsGetTradesAnalyticsData,
	BacktestsHealthCheckData,
	BacktestsUpdateBacktestData,
	BacktestsUpdateBacktestError,
	BacktestsUpdateBacktestResponse,
	HealthHealthCheckData,
	HealthLivenessProbeData,
	HealthReadinessProbeData,
	MarketDataV2GetAnalystRecommendationsData,
	MarketDataV2GetAvailableSymbolsData,
	MarketDataV2GetBalanceSheetData,
	MarketDataV2GetCashFlowData,
	MarketDataV2GetCompanyOverviewData,
	MarketDataV2GetConsumerSentimentData,
	MarketDataV2GetDailyPricesData,
	MarketDataV2GetEarningsData,
	MarketDataV2GetEmploymentDataData,
	MarketDataV2GetGdpDataData,
	MarketDataV2GetHistoricalDataData,
	MarketDataV2GetIncomeStatementData,
	MarketDataV2GetInflationDataData,
	MarketDataV2GetInterestRatesData,
	MarketDataV2GetIntradayDataData,
	MarketDataV2GetMarketDataInfoData,
	MarketDataV2GetNewsData,
	MarketDataV2GetQuoteData,
	MarketDataV2GetSentimentAnalysisData,
	MarketDataV2GetSocialSentimentData,
	MarketDataV2HealthCheckData,
	OAuth2AuthorizeData,
	OAuth2CallbackData,
	PipelineCollectDailyDataData,
	PipelineCollectDailyDataError,
	PipelineCollectStockInfoData,
	PipelineCollectStockInfoError,
	PipelineCreateWatchlistData,
	PipelineCreateWatchlistError,
	PipelineDeleteWatchlistData,
	PipelineDeleteWatchlistError,
	PipelineGetCompanyInfoData,
	PipelineGetPipelineStatusData,
	PipelineGetSymbolCoverageData,
	PipelineGetWatchlistData,
	PipelineListCompaniesData,
	PipelineListWatchlistsData,
	PipelineRunPipelineUpdateData,
	PipelineRunPipelineUpdateError,
	PipelineSetupDefaultSymbolsData,
	PipelineSetupDefaultSymbolsError,
	PipelineUpdateWatchlistByNameData,
	PipelineUpdateWatchlistByNameError,
	PipelineUpdateWatchlistData,
	PipelineUpdateWatchlistError,
	StrategyCreateStrategyData,
	StrategyCreateStrategyError,
	StrategyCreateStrategyFromTemplateData,
	StrategyCreateStrategyFromTemplateError,
	StrategyCreateStrategyFromTemplateResponse,
	StrategyCreateStrategyResponse,
	StrategyCreateTemplateData,
	StrategyCreateTemplateError,
	StrategyCreateTemplateResponse,
	StrategyDeleteStrategyData,
	StrategyDeleteStrategyError,
	StrategyDeleteTemplateData,
	StrategyDeleteTemplateError,
	StrategyExecuteStrategyData,
	StrategyExecuteStrategyError,
	StrategyExecuteStrategyResponse,
	StrategyGetStrategiesData,
	StrategyGetStrategyData,
	StrategyGetStrategyExecutionsData,
	StrategyGetStrategyPerformanceData,
	StrategyGetTemplateData,
	StrategyGetTemplatesData,
	StrategyGetTemplateUsageStatsData,
	StrategyUpdateStrategyData,
	StrategyUpdateStrategyError,
	StrategyUpdateStrategyResponse,
	StrategyUpdateTemplateData,
	StrategyUpdateTemplateError,
	StrategyUpdateTemplateResponse,
	UserDeleteUserData,
	UserDeleteUserError,
	UserDeleteUserResponse,
	UserGetMyOauthAccountsData,
	UserGetUserData,
	UserGetUserMeData,
	UserGetUserOauthAccountsData,
	UserRemoveOauthAccountData,
	UserRemoveOauthAccountError,
	UserRemoveOauthAccountResponse,
	UserUpdateUserData,
	UserUpdateUserError,
	UserUpdateUserMeData,
	UserUpdateUserMeError,
	UserUpdateUserMeResponse,
	UserUpdateUserResponse,
} from "../types.gen";

export type QueryKey<TOptions extends Options> = [
	Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
		_id: string;
		_infinite?: boolean;
		tags?: ReadonlyArray<string>;
	},
];

const createQueryKey = <TOptions extends Options>(
	id: string,
	options?: TOptions,
	infinite?: boolean,
	tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
	const params: QueryKey<TOptions>[0] = {
		_id: id,
		baseUrl:
			options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
	} as QueryKey<TOptions>[0];
	if (infinite) {
		params._infinite = infinite;
	}
	if (tags) {
		params.tags = tags;
	}
	if (options?.body) {
		params.body = options.body;
	}
	if (options?.headers) {
		params.headers = options.headers;
	}
	if (options?.path) {
		params.path = options.path;
	}
	if (options?.query) {
		params.query = options.query;
	}
	return [params];
};

export const healthHealthCheckQueryKey = (
	options?: Options<HealthHealthCheckData>,
) => createQueryKey("healthHealthCheck", options);

/**
 * Health Check
 * Get comprehensive health status.
 */
export const healthHealthCheckOptions = (
	options?: Options<HealthHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.healthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthHealthCheckQueryKey(options),
	});
};

export const healthLivenessProbeQueryKey = (
	options?: Options<HealthLivenessProbeData>,
) => createQueryKey("healthLivenessProbe", options);

/**
 * Liveness Probe
 * Kubernetes liveness probe endpoint.
 */
export const healthLivenessProbeOptions = (
	options?: Options<HealthLivenessProbeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.livenessProbe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthLivenessProbeQueryKey(options),
	});
};

export const healthReadinessProbeQueryKey = (
	options?: Options<HealthReadinessProbeData>,
) => createQueryKey("healthReadinessProbe", options);

/**
 * Readiness Probe
 * Kubernetes readiness probe endpoint.
 */
export const healthReadinessProbeOptions = (
	options?: Options<HealthReadinessProbeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.readinessProbe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthReadinessProbeQueryKey(options),
	});
};

/**
 * Login
 */
export const authLoginMutation = (
	options?: Partial<Options<AuthLoginData>>,
): UseMutationOptions<
	AuthLoginResponse,
	AuthLoginError,
	Options<AuthLoginData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthLoginResponse,
		AuthLoginError,
		Options<AuthLoginData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.login({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Logout
 * 로그아웃 엔드포인트.
 *
 * 쿠키에서 토큰을 삭제하고 로그아웃 처리를 합니다.
 */
export const authLogoutMutation = (
	options?: Partial<Options<AuthLogoutData>>,
): UseMutationOptions<
	AuthLogoutResponse,
	AuthLogoutError,
	Options<AuthLogoutData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthLogoutResponse,
		AuthLogoutError,
		Options<AuthLogoutData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.logout({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Refresh Token
 * JWT 토큰 갱신 엔드포인트
 */
export const authRefreshTokenMutation = (
	options?: Partial<Options<AuthRefreshTokenData>>,
): UseMutationOptions<
	AuthRefreshTokenResponse,
	AuthRefreshTokenError,
	Options<AuthRefreshTokenData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthRefreshTokenResponse,
		AuthRefreshTokenError,
		Options<AuthRefreshTokenData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.refreshToken({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const authVerifyTokenQueryKey = (
	options?: Options<AuthVerifyTokenData>,
) => createQueryKey("authVerifyToken", options);

/**
 * Verify Token
 * 토큰 검증 및 사용자 정보 반환 (디버깅용)
 */
export const authVerifyTokenOptions = (
	options?: Options<AuthVerifyTokenData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await AuthService.verifyToken({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: authVerifyTokenQueryKey(options),
	});
};

/**
 * Register
 */
export const authRegisterMutation = (
	options?: Partial<Options<AuthRegisterData>>,
): UseMutationOptions<
	AuthRegisterResponse,
	AuthRegisterError,
	Options<AuthRegisterData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthRegisterResponse,
		AuthRegisterError,
		Options<AuthRegisterData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.register({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Forgot Password
 */
export const authForgotPasswordMutation = (
	options?: Partial<Options<AuthForgotPasswordData>>,
): UseMutationOptions<
	unknown,
	AuthForgotPasswordError,
	Options<AuthForgotPasswordData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthForgotPasswordError,
		Options<AuthForgotPasswordData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.forgotPassword({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Reset Password
 */
export const authResetPasswordMutation = (
	options?: Partial<Options<AuthResetPasswordData>>,
): UseMutationOptions<
	unknown,
	AuthResetPasswordError,
	Options<AuthResetPasswordData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthResetPasswordError,
		Options<AuthResetPasswordData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.resetPassword({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Request Verify Token
 */
export const authRequestVerifyTokenMutation = (
	options?: Partial<Options<AuthRequestVerifyTokenData>>,
): UseMutationOptions<
	unknown,
	AuthRequestVerifyTokenError,
	Options<AuthRequestVerifyTokenData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthRequestVerifyTokenError,
		Options<AuthRequestVerifyTokenData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.requestVerifyToken({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Verify
 */
export const authVerifyMutation = (
	options?: Partial<Options<AuthVerifyData>>,
): UseMutationOptions<
	AuthVerifyResponse,
	AuthVerifyError,
	Options<AuthVerifyData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthVerifyResponse,
		AuthVerifyError,
		Options<AuthVerifyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.verify({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserMeQueryKey = (options?: Options<UserGetUserMeData>) =>
	createQueryKey("userGetUserMe", options);

/**
 * Get User Me
 */
export const userGetUserMeOptions = (options?: Options<UserGetUserMeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getUserMe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserMeQueryKey(options),
	});
};

/**
 * Update User Me
 */
export const userUpdateUserMeMutation = (
	options?: Partial<Options<UserUpdateUserMeData>>,
): UseMutationOptions<
	UserUpdateUserMeResponse,
	UserUpdateUserMeError,
	Options<UserUpdateUserMeData>
> => {
	const mutationOptions: UseMutationOptions<
		UserUpdateUserMeResponse,
		UserUpdateUserMeError,
		Options<UserUpdateUserMeData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.updateUserMe({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete User
 */
export const userDeleteUserMutation = (
	options?: Partial<Options<UserDeleteUserData>>,
): UseMutationOptions<
	UserDeleteUserResponse,
	UserDeleteUserError,
	Options<UserDeleteUserData>
> => {
	const mutationOptions: UseMutationOptions<
		UserDeleteUserResponse,
		UserDeleteUserError,
		Options<UserDeleteUserData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.deleteUser({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserQueryKey = (options: Options<UserGetUserData>) =>
	createQueryKey("userGetUser", options);

/**
 * Get User
 */
export const userGetUserOptions = (options: Options<UserGetUserData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getUser({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserQueryKey(options),
	});
};

/**
 * Update User
 */
export const userUpdateUserMutation = (
	options?: Partial<Options<UserUpdateUserData>>,
): UseMutationOptions<
	UserUpdateUserResponse,
	UserUpdateUserError,
	Options<UserUpdateUserData>
> => {
	const mutationOptions: UseMutationOptions<
		UserUpdateUserResponse,
		UserUpdateUserError,
		Options<UserUpdateUserData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.updateUser({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const oAuth2AuthorizeQueryKey = (
	options: Options<OAuth2AuthorizeData>,
) => createQueryKey("oAuth2Authorize", options);

/**
 * Authorize
 * Initiate the OAuth2 authorization process for associating an OAuth account
 * with the currently authenticated user.
 */
export const oAuth2AuthorizeOptions = (
	options: Options<OAuth2AuthorizeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await OAuth2Service.authorize({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: oAuth2AuthorizeQueryKey(options),
	});
};

export const oAuth2CallbackQueryKey = (options: Options<OAuth2CallbackData>) =>
	createQueryKey("oAuth2Callback", options);

/**
 * Callback
 * The response varies based on the authentication backend used.
 */
export const oAuth2CallbackOptions = (options: Options<OAuth2CallbackData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await OAuth2Service.callback({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: oAuth2CallbackQueryKey(options),
	});
};

export const userGetMyOauthAccountsQueryKey = (
	options?: Options<UserGetMyOauthAccountsData>,
) => createQueryKey("userGetMyOauthAccounts", options);

/**
 * Get My Oauth Accounts
 * 현재 사용자의 연결된 OAuth 계정 목록을 조회합니다.
 */
export const userGetMyOauthAccountsOptions = (
	options?: Options<UserGetMyOauthAccountsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getMyOauthAccounts({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetMyOauthAccountsQueryKey(options),
	});
};

/**
 * Remove Oauth Account
 * 특정 OAuth 계정 연결을 해제합니다.
 */
export const userRemoveOauthAccountMutation = (
	options?: Partial<Options<UserRemoveOauthAccountData>>,
): UseMutationOptions<
	UserRemoveOauthAccountResponse,
	UserRemoveOauthAccountError,
	Options<UserRemoveOauthAccountData>
> => {
	const mutationOptions: UseMutationOptions<
		UserRemoveOauthAccountResponse,
		UserRemoveOauthAccountError,
		Options<UserRemoveOauthAccountData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.removeOauthAccount({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserOauthAccountsQueryKey = (
	options: Options<UserGetUserOauthAccountsData>,
) => createQueryKey("userGetUserOauthAccounts", options);

/**
 * Get User Oauth Accounts
 * 특정 사용자의 OAuth 계정 목록을 조회합니다. (관리자 전용)
 */
export const userGetUserOauthAccountsOptions = (
	options: Options<UserGetUserOauthAccountsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getUserOauthAccounts({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserOauthAccountsQueryKey(options),
	});
};

export const marketDataV2GetDailyPricesQueryKey = (
	options: Options<MarketDataV2GetDailyPricesData>,
) => createQueryKey("marketDataV2GetDailyPrices", options);

/**
 * 일일 주가 데이터 조회
 * 지정된 종목의 일일 주가 데이터(OHLCV)를 조회합니다.
 */
export const marketDataV2GetDailyPricesOptions = (
	options: Options<MarketDataV2GetDailyPricesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.일일주가데이터조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetDailyPricesQueryKey(options),
	});
};

export const marketDataV2GetQuoteQueryKey = (
	options: Options<MarketDataV2GetQuoteData>,
) => createQueryKey("marketDataV2GetQuote", options);

/**
 * 실시간 주식 호가 조회
 * 지정된 종목의 실시간 호가 정보를 조회합니다.
 */
export const marketDataV2GetQuoteOptions = (
	options: Options<MarketDataV2GetQuoteData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.실시간주식호가조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetQuoteQueryKey(options),
	});
};

export const marketDataV2GetIntradayDataQueryKey = (
	options: Options<MarketDataV2GetIntradayDataData>,
) => createQueryKey("marketDataV2GetIntradayData", options);

/**
 * 실시간/인트라데이 데이터 조회
 * 지정된 종목의 실시간 또는 분봉 데이터를 조회합니다.
 */
export const marketDataV2GetIntradayDataOptions = (
	options: Options<MarketDataV2GetIntradayDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } =
				(await MarketDataV2Service.실시간) /
				인트라데이데이터조회({
					...options,
					...queryKey[0],
					signal,
					throwOnError: true,
				});
			return data;
		},
		queryKey: marketDataV2GetIntradayDataQueryKey(options),
	});
};

export const marketDataV2GetHistoricalDataQueryKey = (
	options: Options<MarketDataV2GetHistoricalDataData>,
) => createQueryKey("marketDataV2GetHistoricalData", options);

/**
 * 장기 히스토리 데이터 조회
 * 지정된 종목의 장기 히스토리 데이터를 조회합니다.
 */
export const marketDataV2GetHistoricalDataOptions = (
	options: Options<MarketDataV2GetHistoricalDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.장기히스토리데이터조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetHistoricalDataQueryKey(options),
	});
};

export const marketDataV2GetAvailableSymbolsQueryKey = (
	options?: Options<MarketDataV2GetAvailableSymbolsData>,
) => createQueryKey("marketDataV2GetAvailableSymbols", options);

/**
 * 사용 가능한 종목 심볼 목록 조회
 * API에서 지원하는 종목 심볼 목록을 조회합니다.
 */
export const marketDataV2GetAvailableSymbolsOptions = (
	options?: Options<MarketDataV2GetAvailableSymbolsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.사용가능한종목심볼목록조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetAvailableSymbolsQueryKey(options),
	});
};

export const marketDataV2GetCompanyOverviewQueryKey = (
	options: Options<MarketDataV2GetCompanyOverviewData>,
) => createQueryKey("marketDataV2GetCompanyOverview", options);

/**
 * 기업 개요 조회
 * 지정된 종목의 기업 개요 정보를 조회합니다.
 */
export const marketDataV2GetCompanyOverviewOptions = (
	options: Options<MarketDataV2GetCompanyOverviewData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.기업개요조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetCompanyOverviewQueryKey(options),
	});
};

export const marketDataV2GetIncomeStatementQueryKey = (
	options: Options<MarketDataV2GetIncomeStatementData>,
) => createQueryKey("marketDataV2GetIncomeStatement", options);

/**
 * 손익계산서 조회
 * 지정된 종목의 손익계산서를 조회합니다.
 */
export const marketDataV2GetIncomeStatementOptions = (
	options: Options<MarketDataV2GetIncomeStatementData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.손익계산서조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetIncomeStatementQueryKey(options),
	});
};

export const marketDataV2GetBalanceSheetQueryKey = (
	options: Options<MarketDataV2GetBalanceSheetData>,
) => createQueryKey("marketDataV2GetBalanceSheet", options);

/**
 * 재무상태표 조회
 * 지정된 종목의 재무상태표를 조회합니다.
 */
export const marketDataV2GetBalanceSheetOptions = (
	options: Options<MarketDataV2GetBalanceSheetData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.재무상태표조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetBalanceSheetQueryKey(options),
	});
};

export const marketDataV2GetCashFlowQueryKey = (
	options: Options<MarketDataV2GetCashFlowData>,
) => createQueryKey("marketDataV2GetCashFlow", options);

/**
 * 현금흐름표 조회
 * 지정된 종목의 현금흐름표를 조회합니다.
 */
export const marketDataV2GetCashFlowOptions = (
	options: Options<MarketDataV2GetCashFlowData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.현금흐름표조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetCashFlowQueryKey(options),
	});
};

export const marketDataV2GetEarningsQueryKey = (
	options: Options<MarketDataV2GetEarningsData>,
) => createQueryKey("marketDataV2GetEarnings", options);

/**
 * 실적 데이터 조회
 * 지정된 종목의 실적 데이터를 조회합니다.
 */
export const marketDataV2GetEarningsOptions = (
	options: Options<MarketDataV2GetEarningsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.실적데이터조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetEarningsQueryKey(options),
	});
};

export const marketDataV2GetGdpDataQueryKey = (
	options?: Options<MarketDataV2GetGdpDataData>,
) => createQueryKey("marketDataV2GetGdpData", options);

/**
 * GDP 데이터 조회
 * 미국 GDP 데이터를 조회합니다.
 */
export const marketDataV2GetGdpDataOptions = (
	options?: Options<MarketDataV2GetGdpDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.gdp데이터조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetGdpDataQueryKey(options),
	});
};

export const marketDataV2GetInflationDataQueryKey = (
	options?: Options<MarketDataV2GetInflationDataData>,
) => createQueryKey("marketDataV2GetInflationData", options);

/**
 * 인플레이션 데이터 조회
 * 미국 인플레이션 지표 데이터를 조회합니다.
 */
export const marketDataV2GetInflationDataOptions = (
	options?: Options<MarketDataV2GetInflationDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.인플레이션데이터조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetInflationDataQueryKey(options),
	});
};

export const marketDataV2GetInterestRatesQueryKey = (
	options?: Options<MarketDataV2GetInterestRatesData>,
) => createQueryKey("marketDataV2GetInterestRates", options);

/**
 * 금리 데이터 조회
 * 미국 기준금리 및 채권 수익률 데이터를 조회합니다.
 */
export const marketDataV2GetInterestRatesOptions = (
	options?: Options<MarketDataV2GetInterestRatesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.금리데이터조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetInterestRatesQueryKey(options),
	});
};

export const marketDataV2GetEmploymentDataQueryKey = (
	options?: Options<MarketDataV2GetEmploymentDataData>,
) => createQueryKey("marketDataV2GetEmploymentData", options);

/**
 * 고용 지표 조회
 * 미국 실업률 및 고용 관련 지표를 조회합니다.
 */
export const marketDataV2GetEmploymentDataOptions = (
	options?: Options<MarketDataV2GetEmploymentDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.고용지표조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetEmploymentDataQueryKey(options),
	});
};

export const marketDataV2GetConsumerSentimentQueryKey = (
	options?: Options<MarketDataV2GetConsumerSentimentData>,
) => createQueryKey("marketDataV2GetConsumerSentiment", options);

/**
 * 소비자 심리 지수 조회
 * 미국 소비자 심리 지수를 조회합니다.
 */
export const marketDataV2GetConsumerSentimentOptions = (
	options?: Options<MarketDataV2GetConsumerSentimentData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.소비자심리지수조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetConsumerSentimentQueryKey(options),
	});
};

export const marketDataV2GetNewsQueryKey = (
	options: Options<MarketDataV2GetNewsData>,
) => createQueryKey("marketDataV2GetNews", options);

/**
 * 종목 뉴스 조회
 * 지정된 종목 관련 뉴스를 조회합니다.
 */
export const marketDataV2GetNewsOptions = (
	options: Options<MarketDataV2GetNewsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.종목뉴스조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetNewsQueryKey(options),
	});
};

export const marketDataV2GetSentimentAnalysisQueryKey = (
	options: Options<MarketDataV2GetSentimentAnalysisData>,
) => createQueryKey("marketDataV2GetSentimentAnalysis", options);

/**
 * 감정 분석 조회
 * 지정된 종목의 감정 분석 결과를 조회합니다.
 */
export const marketDataV2GetSentimentAnalysisOptions = (
	options: Options<MarketDataV2GetSentimentAnalysisData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.감정분석조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetSentimentAnalysisQueryKey(options),
	});
};

export const marketDataV2GetAnalystRecommendationsQueryKey = (
	options: Options<MarketDataV2GetAnalystRecommendationsData>,
) => createQueryKey("marketDataV2GetAnalystRecommendations", options);

/**
 * 분석가 추천 조회
 * 지정된 종목의 분석가 추천 정보를 조회합니다.
 */
export const marketDataV2GetAnalystRecommendationsOptions = (
	options: Options<MarketDataV2GetAnalystRecommendationsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.분석가추천조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetAnalystRecommendationsQueryKey(options),
	});
};

export const marketDataV2GetSocialSentimentQueryKey = (
	options: Options<MarketDataV2GetSocialSentimentData>,
) => createQueryKey("marketDataV2GetSocialSentiment", options);

/**
 * 소셜 미디어 감정 분석 조회
 * 지정된 종목의 소셜 미디어 감정 분석을 조회합니다.
 */
export const marketDataV2GetSocialSentimentOptions = (
	options: Options<MarketDataV2GetSocialSentimentData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.소셜미디어감정분석조회({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetSocialSentimentQueryKey(options),
	});
};

export const marketDataV2GetMarketDataInfoQueryKey = (
	options?: Options<MarketDataV2GetMarketDataInfoData>,
) => createQueryKey("marketDataV2GetMarketDataInfo", options);

/**
 * Market Data API 정보
 * 마켓 데이터 API 정보 및 사용 가능한 엔드포인트 목록
 */
export const marketDataV2GetMarketDataInfoOptions = (
	options?: Options<MarketDataV2GetMarketDataInfoData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.marketDataApi정보({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2GetMarketDataInfoQueryKey(options),
	});
};

export const marketDataV2HealthCheckQueryKey = (
	options?: Options<MarketDataV2HealthCheckData>,
) => createQueryKey("marketDataV2HealthCheck", options);

/**
 * Market Data 서비스 상태 확인
 * 마켓 데이터 서비스 상태 확인
 */
export const marketDataV2HealthCheckOptions = (
	options?: Options<MarketDataV2HealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataV2Service.marketData서비스상태확인({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataV2HealthCheckQueryKey(options),
	});
};

/**
 * Update Watchlist
 * Create or update a watchlist with flexible naming support.
 *
 * This endpoint provides a convenient way to create new watchlists or update
 * existing ones. If no name is provided, it defaults to the 'default' watchlist
 * which is used by the pipeline for automated updates. This endpoint combines
 * creation and update functionality for ease of use.
 *
 * Args:
 * request: Watchlist configuration containing:
 * - symbols: List of stock symbols to include
 * - name: Optional watchlist name (defaults to 'default')
 * - description: Optional description of the watchlist
 *
 * Returns:
 * dict: Operation result containing:
 * - message: Success message indicating action taken
 * - name: Watchlist name that was processed
 * - symbols: List of symbols in the watchlist
 * - count: Number of symbols in the watchlist
 * - action: Either 'created' or 'updated'
 *
 * Raises:
 * HTTPException: 400 if watchlist creation fails
 * HTTPException: 500 if operation fails
 *
 * Note:
 * Updates to the 'default' watchlist automatically update pipeline symbols.
 * This affects which symbols are processed during automated updates.
 */
export const pipelineUpdateWatchlistMutation = (
	options?: Partial<Options<PipelineUpdateWatchlistData>>,
): UseMutationOptions<
	unknown,
	PipelineUpdateWatchlistError,
	Options<PipelineUpdateWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineUpdateWatchlistError,
		Options<PipelineUpdateWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.updateWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const pipelineListWatchlistsQueryKey = (
	options?: Options<PipelineListWatchlistsData>,
) => createQueryKey("pipelineListWatchlists", options);

/**
 * List Watchlists
 * Retrieve a comprehensive list of all watchlists.
 *
 * Returns summary information for all watchlists in the system, including
 * metadata like symbol counts, update settings, and timestamps. This is
 * useful for dashboard displays and watchlist management interfaces.
 *
 * Returns:
 * dict: All watchlists summary containing:
 * - watchlists: List of watchlist summaries with:
 * - name: Watchlist name
 * - description: Watchlist description
 * - symbol_count: Number of symbols in the watchlist
 * - auto_update: Whether automatic updates are enabled
 * - last_updated: Timestamp of last modification
 * - created_at: Timestamp of creation
 * - total_count: Total number of watchlists in the system
 *
 * Raises:
 * HTTPException: 500 if retrieval fails
 *
 * Note:
 * This endpoint returns summary data only. Use GET /watchlists/{name}
 * for detailed information including full symbol lists.
 */
export const pipelineListWatchlistsOptions = (
	options?: Options<PipelineListWatchlistsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.listWatchlists({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineListWatchlistsQueryKey(options),
	});
};

/**
 * Create Watchlist
 * Create a new named watchlist with validation.
 *
 * This endpoint is specifically for creating new watchlists with explicit
 * naming requirements. Unlike the /watchlist endpoint, this requires a name
 * and will fail if a watchlist with the same name already exists.
 *
 * Args:
 * request: Watchlist creation parameters containing:
 * - name: Required unique name for the watchlist
 * - symbols: List of stock symbols to include
 * - description: Optional description of the watchlist purpose
 *
 * Returns:
 * dict: Creation result containing:
 * - message: Success confirmation message
 * - name: Name of the created watchlist
 * - symbols: List of symbols in the watchlist
 * - description: Watchlist description
 * - created_at: UTC timestamp of creation
 *
 * Raises:
 * HTTPException: 400 if watchlist creation fails or name conflicts
 * HTTPException: 500 if database operation fails
 *
 * Note:
 * Watchlist names must be unique. Use PUT /watchlists/{name} to update existing ones.
 */
export const pipelineCreateWatchlistMutation = (
	options?: Partial<Options<PipelineCreateWatchlistData>>,
): UseMutationOptions<
	unknown,
	PipelineCreateWatchlistError,
	Options<PipelineCreateWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineCreateWatchlistError,
		Options<PipelineCreateWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.createWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Watchlist
 * Delete a named watchlist from the system.
 *
 * Permanently removes a watchlist and all associated metadata. This action
 * cannot be undone. The 'default' watchlist cannot be deleted as it is
 * required for pipeline operations.
 *
 * Args:
 * name: Name of the watchlist to delete
 *
 * Returns:
 * dict: Deletion confirmation containing:
 * - message: Success confirmation message
 * - name: Name of the deleted watchlist
 *
 * Raises:
 * HTTPException: 400 if attempting to delete the 'default' watchlist
 * HTTPException: 404 if watchlist with specified name not found
 * HTTPException: 500 if deletion operation fails
 *
 * Note:
 * Deletion is permanent and cannot be undone. Consider backing up
 * important watchlists before deletion.
 */
export const pipelineDeleteWatchlistMutation = (
	options?: Partial<Options<PipelineDeleteWatchlistData>>,
): UseMutationOptions<
	unknown,
	PipelineDeleteWatchlistError,
	Options<PipelineDeleteWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineDeleteWatchlistError,
		Options<PipelineDeleteWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.deleteWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const pipelineGetWatchlistQueryKey = (
	options: Options<PipelineGetWatchlistData>,
) => createQueryKey("pipelineGetWatchlist", options);

/**
 * Get Watchlist
 * Retrieve complete information for a specific watchlist.
 *
 * Returns detailed information about a named watchlist including the full
 * list of symbols, configuration settings, and all metadata. This provides
 * all information needed to display or modify a specific watchlist.
 *
 * Args:
 * name: Name of the watchlist to retrieve (case-sensitive)
 *
 * Returns:
 * dict: Complete watchlist information containing:
 * - name: Watchlist name
 * - description: Detailed description
 * - symbols: Complete list of stock symbols
 * - auto_update: Automatic update configuration
 * - update_interval: Update frequency in seconds
 * - last_updated: Timestamp of last symbol update
 * - created_at: Timestamp of watchlist creation
 *
 * Raises:
 * HTTPException: 404 if watchlist with specified name not found
 * HTTPException: 500 if retrieval operation fails
 *
 * Note:
 * Watchlist names are case-sensitive. Use GET /watchlists to see all available names.
 */
export const pipelineGetWatchlistOptions = (
	options: Options<PipelineGetWatchlistData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.getWatchlist({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineGetWatchlistQueryKey(options),
	});
};

/**
 * Update Watchlist By Name
 * Update an existing watchlist with new symbols and settings.
 *
 * Modifies the symbols and metadata of an existing watchlist. This endpoint
 * requires the watchlist to exist and will fail if the specified name is
 * not found. Use POST /watchlists to create new watchlists.
 *
 * Args:
 * name: Name of the existing watchlist to update
 * request: Update parameters containing:
 * - symbols: New list of symbols (replaces current list)
 * - description: Optional new description (if provided)
 *
 * Returns:
 * dict: Update confirmation containing:
 * - message: Success confirmation message
 * - name: Name of the updated watchlist
 * - symbols: New symbols list
 * - description: Current description (updated if provided)
 * - count: Number of symbols in updated watchlist
 * - updated_at: Timestamp of the update
 *
 * Raises:
 * HTTPException: 404 if watchlist with specified name not found
 * HTTPException: 500 if update operation fails
 *
 * Note:
 * Updates to the 'default' watchlist automatically update pipeline symbols.
 * Symbol list is completely replaced, not merged with existing symbols.
 */
export const pipelineUpdateWatchlistByNameMutation = (
	options?: Partial<Options<PipelineUpdateWatchlistByNameData>>,
): UseMutationOptions<
	unknown,
	PipelineUpdateWatchlistByNameError,
	Options<PipelineUpdateWatchlistByNameData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineUpdateWatchlistByNameError,
		Options<PipelineUpdateWatchlistByNameData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.updateWatchlistByName({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Collect Stock Info
 * Collect and store basic company information for a specific symbol.
 *
 * Retrieves fundamental company data from external APIs (Alpha Vantage)
 * including company name, sector, industry, market cap, and key financial
 * ratios. This information is stored in the database for future reference
 * and analysis.
 *
 * Args:
 * symbol: Stock symbol (e.g., 'AAPL', 'MSFT') - automatically converted to uppercase
 *
 * Returns:
 * dict: Collection result containing:
 * - message: Success/failure message
 * - symbol: Processed symbol (uppercase)
 * - success: Boolean indicating operation success
 *
 * Raises:
 * HTTPException: 500 if data collection fails
 *
 * Note:
 * Respects Alpha Vantage API rate limits (5 calls/min, 500 calls/day).
 * Duplicate requests for same symbol within 24 hours may return cached data.
 */
export const pipelineCollectStockInfoMutation = (
	options?: Partial<Options<PipelineCollectStockInfoData>>,
): UseMutationOptions<
	unknown,
	PipelineCollectStockInfoError,
	Options<PipelineCollectStockInfoData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineCollectStockInfoError,
		Options<PipelineCollectStockInfoData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.collectStockInfo({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Collect Daily Data
 * Collect historical daily price data for a specific symbol.
 *
 * Retrieves OHLCV (Open, High, Low, Close, Volume) daily price data
 * for the specified symbol and date range. If no dates are provided,
 * collects maximum available historical data. Data is validated,
 * adjusted for splits/dividends, and stored in DuckDB for fast access.
 *
 * Args:
 * symbol: Stock symbol (e.g., 'AAPL') - automatically converted to uppercase
 * start_date: Optional start date for data collection (defaults to earliest available)
 * end_date: Optional end date for data collection (defaults to latest available)
 *
 * Returns:
 * dict: Collection result containing:
 * - message: Detailed success/failure message
 * - symbol: Processed symbol (uppercase)
 * - start_date: Actual start date used
 * - end_date: Actual end date used
 * - success: Boolean indicating operation success
 *
 * Raises:
 * HTTPException: 500 if data collection fails
 *
 * Note:
 * Large date ranges may take several minutes to complete.
 * Data is automatically cached to minimize API calls.
 */
export const pipelineCollectDailyDataMutation = (
	options?: Partial<Options<PipelineCollectDailyDataData>>,
): UseMutationOptions<
	unknown,
	PipelineCollectDailyDataError,
	Options<PipelineCollectDailyDataData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineCollectDailyDataError,
		Options<PipelineCollectDailyDataData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.collectDailyData({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const pipelineGetSymbolCoverageQueryKey = (
	options: Options<PipelineGetSymbolCoverageData>,
) => createQueryKey("pipelineGetSymbolCoverage", options);

/**
 * Get Symbol Coverage
 * Get detailed data coverage information for a specific symbol.
 *
 * Returns comprehensive information about the availability and quality
 * of data for the specified symbol, including date ranges, data gaps,
 * last update timestamps, and data quality metrics.
 *
 * Args:
 * symbol: Stock symbol to check coverage for (automatically converted to uppercase)
 *
 * Returns:
 * dict: Coverage information containing:
 * - symbol: Processed symbol
 * - date_range: Start and end dates of available data
 * - total_records: Number of data points available
 * - gaps: List of date ranges with missing data
 * - last_updated: Timestamp of most recent data update
 * - data_quality: Quality metrics (completeness, accuracy scores)
 *
 * Raises:
 * HTTPException: 500 if coverage check fails
 * HTTPException: 404 if symbol not found in database
 */
export const pipelineGetSymbolCoverageOptions = (
	options: Options<PipelineGetSymbolCoverageData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.getSymbolCoverage({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineGetSymbolCoverageQueryKey(options),
	});
};

export const pipelineGetCompanyInfoQueryKey = (
	options: Options<PipelineGetCompanyInfoData>,
) => createQueryKey("pipelineGetCompanyInfo", options);

/**
 * Get Company Info
 * Retrieve stored company information for a specific symbol.
 *
 * Returns comprehensive company fundamentals and metadata previously
 * collected and stored in the database. This includes financial ratios,
 * company description, sector classification, and market data.
 *
 * Args:
 * symbol: Stock symbol (automatically converted to uppercase)
 *
 * Returns:
 * dict: Company information containing:
 * - symbol: Stock symbol
 * - name: Company name
 * - description: Business description
 * - sector: Industry sector classification
 * - industry: Specific industry classification
 * - country: Country of incorporation
 * - currency: Reporting currency
 * - market_cap: Market capitalization (if available)
 * - pe_ratio: Price-to-earnings ratio (if available)
 * - dividend_yield: Annual dividend yield (if available)
 * - updated_at: Last information update timestamp
 *
 * Raises:
 * HTTPException: 404 if company information not found
 * HTTPException: 500 if retrieval fails
 *
 * Note:
 * If company info not found, use POST /collect-info/{symbol} first.
 */
export const pipelineGetCompanyInfoOptions = (
	options: Options<PipelineGetCompanyInfoData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.getCompanyInfo({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineGetCompanyInfoQueryKey(options),
	});
};

export const pipelineListCompaniesQueryKey = (
	options?: Options<PipelineListCompaniesData>,
) => createQueryKey("pipelineListCompanies", options);

/**
 * List Companies
 * Retrieve information for all companies in the database.
 *
 * Returns a comprehensive list of all companies for which information
 * has been collected and stored. Useful for portfolio analysis,
 * screening, and getting an overview of available data.
 *
 * Returns:
 * dict: All companies data containing:
 * - companies: List of company objects with key information:
 * - symbol: Stock symbol
 * - name: Company name
 * - sector: Industry sector
 * - industry: Specific industry
 * - market_cap: Market capitalization
 * - updated_at: Last update timestamp
 * - total_count: Total number of companies in database
 *
 * Raises:
 * HTTPException: 500 if retrieval fails
 *
 * Note:
 * Large datasets may take time to load. Consider pagination for production use.
 */
export const pipelineListCompaniesOptions = (
	options?: Options<PipelineListCompaniesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.listCompanies({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineListCompaniesQueryKey(options),
	});
};

export const pipelineGetPipelineStatusQueryKey = (
	options?: Options<PipelineGetPipelineStatusData>,
) => createQueryKey("pipelineGetPipelineStatus", options);

/**
 * Get Pipeline Status
 * Get comprehensive pipeline status and health information.
 *
 * Returns detailed information about the current state of the data pipeline,
 * including data coverage statistics, update timestamps, and system health metrics.
 * This endpoint is essential for monitoring the overall health of the data
 * collection and processing system.
 *
 * Returns:
 * dict: Pipeline status containing:
 * - overall_status: Current pipeline health status
 * - last_update: Timestamp of last successful update
 * - coverage_stats: Data coverage statistics per symbol
 * - active_symbols: Currently monitored symbols count
 * - error_count: Number of recent errors
 *
 * Raises:
 * HTTPException: 500 if status retrieval fails
 */
export const pipelineGetPipelineStatusOptions = (
	options?: Options<PipelineGetPipelineStatusData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.getPipelineStatus({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineGetPipelineStatusQueryKey(options),
	});
};

/**
 * Setup Default Symbols
 * Initialize default watchlist with standard symbols.
 *
 * Sets up the pipeline with a predefined set of popular stock symbols
 * for immediate use. This is typically called during initial system setup
 * or when resetting the pipeline to defaults. Creates the 'default' watchlist
 * if it doesn't exist.
 *
 * Default symbols include major tech stocks: AAPL, MSFT, GOOGL, AMZN, etc.
 *
 * Returns:
 * dict: Setup confirmation containing:
 * - message: Success confirmation message
 * - symbols: List of symbols that were set up
 *
 * Raises:
 * HTTPException: 500 if default setup fails
 */
export const pipelineSetupDefaultSymbolsMutation = (
	options?: Partial<Options<PipelineSetupDefaultSymbolsData>>,
): UseMutationOptions<
	unknown,
	PipelineSetupDefaultSymbolsError,
	Options<PipelineSetupDefaultSymbolsData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineSetupDefaultSymbolsError,
		Options<PipelineSetupDefaultSymbolsData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.setupDefaultSymbols({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Run Pipeline Update
 * Execute comprehensive data pipeline update for specified symbols.
 *
 * Initiates a full data collection and update process for the specified
 * symbols or the default watchlist. The update runs asynchronously in the
 * background to avoid blocking the API response. Includes company information
 * retrieval, historical price data collection, and data validation.
 *
 * Args:
 * request: Update configuration containing:
 * - symbols: Optional list of symbols to update (uses default if None)
 * - start_date: Optional start date for data collection
 * - end_date: Optional end date for data collection
 * background_tasks: FastAPI background task manager
 *
 * Returns:
 * dict: Update initiation confirmation containing:
 * - message: Update start confirmation
 * - symbols: Symbols being updated
 * - started_at: UTC timestamp when update began
 *
 * Raises:
 * HTTPException: 500 if update initiation fails
 *
 * Note:
 * This is an asynchronous operation. Use /status endpoint to monitor progress.
 */
export const pipelineRunPipelineUpdateMutation = (
	options?: Partial<Options<PipelineRunPipelineUpdateData>>,
): UseMutationOptions<
	unknown,
	PipelineRunPipelineUpdateError,
	Options<PipelineRunPipelineUpdateData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineRunPipelineUpdateError,
		Options<PipelineRunPipelineUpdateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.runPipelineUpdate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetStrategiesQueryKey = (
	options?: Options<StrategyGetStrategiesData>,
) => createQueryKey("strategyGetStrategies", options);

/**
 * Get Strategies
 * Get list of strategies
 */
export const strategyGetStrategiesOptions = (
	options?: Options<StrategyGetStrategiesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategies({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategiesQueryKey(options),
	});
};

/**
 * Create Strategy
 * Create a new strategy
 */
export const strategyCreateStrategyMutation = (
	options?: Partial<Options<StrategyCreateStrategyData>>,
): UseMutationOptions<
	StrategyCreateStrategyResponse,
	StrategyCreateStrategyError,
	Options<StrategyCreateStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateStrategyResponse,
		StrategyCreateStrategyError,
		Options<StrategyCreateStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.createStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Strategy
 * Delete strategy (soft delete)
 */
export const strategyDeleteStrategyMutation = (
	options?: Partial<Options<StrategyDeleteStrategyData>>,
): UseMutationOptions<
	unknown,
	StrategyDeleteStrategyError,
	Options<StrategyDeleteStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		StrategyDeleteStrategyError,
		Options<StrategyDeleteStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.deleteStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetStrategyQueryKey = (
	options: Options<StrategyGetStrategyData>,
) => createQueryKey("strategyGetStrategy", options);

/**
 * Get Strategy
 * Get strategy by ID
 */
export const strategyGetStrategyOptions = (
	options: Options<StrategyGetStrategyData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategy({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyQueryKey(options),
	});
};

/**
 * Update Strategy
 * Update strategy
 */
export const strategyUpdateStrategyMutation = (
	options?: Partial<Options<StrategyUpdateStrategyData>>,
): UseMutationOptions<
	StrategyUpdateStrategyResponse,
	StrategyUpdateStrategyError,
	Options<StrategyUpdateStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyUpdateStrategyResponse,
		StrategyUpdateStrategyError,
		Options<StrategyUpdateStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.updateStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Execute Strategy
 * Execute strategy and generate signal
 */
export const strategyExecuteStrategyMutation = (
	options?: Partial<Options<StrategyExecuteStrategyData>>,
): UseMutationOptions<
	StrategyExecuteStrategyResponse,
	StrategyExecuteStrategyError,
	Options<StrategyExecuteStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyExecuteStrategyResponse,
		StrategyExecuteStrategyError,
		Options<StrategyExecuteStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.executeStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetStrategyExecutionsQueryKey = (
	options: Options<StrategyGetStrategyExecutionsData>,
) => createQueryKey("strategyGetStrategyExecutions", options);

/**
 * Get Strategy Executions
 * Get strategy execution history
 */
export const strategyGetStrategyExecutionsOptions = (
	options: Options<StrategyGetStrategyExecutionsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategyExecutions({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyExecutionsQueryKey(options),
	});
};

export const strategyGetStrategyPerformanceQueryKey = (
	options: Options<StrategyGetStrategyPerformanceData>,
) => createQueryKey("strategyGetStrategyPerformance", options);

/**
 * Get Strategy Performance
 * Get strategy performance metrics
 */
export const strategyGetStrategyPerformanceOptions = (
	options: Options<StrategyGetStrategyPerformanceData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategyPerformance({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyPerformanceQueryKey(options),
	});
};

export const strategyGetTemplatesQueryKey = (
	options?: Options<StrategyGetTemplatesData>,
) => createQueryKey("strategyGetTemplates", options);

/**
 * Get Templates
 * Get list of strategy templates
 */
export const strategyGetTemplatesOptions = (
	options?: Options<StrategyGetTemplatesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getTemplates({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplatesQueryKey(options),
	});
};

/**
 * Create Template
 * Create a new strategy template (Superuser only)
 */
export const strategyCreateTemplateMutation = (
	options?: Partial<Options<StrategyCreateTemplateData>>,
): UseMutationOptions<
	StrategyCreateTemplateResponse,
	StrategyCreateTemplateError,
	Options<StrategyCreateTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateTemplateResponse,
		StrategyCreateTemplateError,
		Options<StrategyCreateTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.createTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Template
 * Delete template by ID (Superuser only)
 */
export const strategyDeleteTemplateMutation = (
	options?: Partial<Options<StrategyDeleteTemplateData>>,
): UseMutationOptions<
	unknown,
	StrategyDeleteTemplateError,
	Options<StrategyDeleteTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		StrategyDeleteTemplateError,
		Options<StrategyDeleteTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.deleteTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetTemplateQueryKey = (
	options: Options<StrategyGetTemplateData>,
) => createQueryKey("strategyGetTemplate", options);

/**
 * Get Template
 * Get template by ID
 */
export const strategyGetTemplateOptions = (
	options: Options<StrategyGetTemplateData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getTemplate({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplateQueryKey(options),
	});
};

/**
 * Update Template
 * Update template by ID (Superuser only)
 */
export const strategyUpdateTemplateMutation = (
	options?: Partial<Options<StrategyUpdateTemplateData>>,
): UseMutationOptions<
	StrategyUpdateTemplateResponse,
	StrategyUpdateTemplateError,
	Options<StrategyUpdateTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyUpdateTemplateResponse,
		StrategyUpdateTemplateError,
		Options<StrategyUpdateTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.updateTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Create Strategy From Template
 * Create a strategy instance from template
 */
export const strategyCreateStrategyFromTemplateMutation = (
	options?: Partial<Options<StrategyCreateStrategyFromTemplateData>>,
): UseMutationOptions<
	StrategyCreateStrategyFromTemplateResponse,
	StrategyCreateStrategyFromTemplateError,
	Options<StrategyCreateStrategyFromTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateStrategyFromTemplateResponse,
		StrategyCreateStrategyFromTemplateError,
		Options<StrategyCreateStrategyFromTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.createStrategyFromTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetTemplateUsageStatsQueryKey = (
	options?: Options<StrategyGetTemplateUsageStatsData>,
) => createQueryKey("strategyGetTemplateUsageStats", options);

/**
 * Get Template Usage Stats
 * Get template usage statistics
 */
export const strategyGetTemplateUsageStatsOptions = (
	options?: Options<StrategyGetTemplateUsageStatsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getTemplateUsageStats({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplateUsageStatsQueryKey(options),
	});
};

export const backtestsGetBacktestsQueryKey = (
	options?: Options<BacktestsGetBacktestsData>,
) => createQueryKey("backtestsGetBacktests", options);

/**
 * Get Backtests
 * Get list of backtests
 */
export const backtestsGetBacktestsOptions = (
	options?: Options<BacktestsGetBacktestsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktests({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestsQueryKey(options),
	});
};

/**
 * Create Backtest
 * Create a new backtest
 */
export const backtestsCreateBacktestMutation = (
	options?: Partial<Options<BacktestsCreateBacktestData>>,
): UseMutationOptions<
	BacktestsCreateBacktestResponse,
	BacktestsCreateBacktestError,
	Options<BacktestsCreateBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsCreateBacktestResponse,
		BacktestsCreateBacktestError,
		Options<BacktestsCreateBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.createBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Backtest
 * Delete backtest
 */
export const backtestsDeleteBacktestMutation = (
	options?: Partial<Options<BacktestsDeleteBacktestData>>,
): UseMutationOptions<
	unknown,
	BacktestsDeleteBacktestError,
	Options<BacktestsDeleteBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		BacktestsDeleteBacktestError,
		Options<BacktestsDeleteBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.deleteBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsGetBacktestQueryKey = (
	options: Options<BacktestsGetBacktestData>,
) => createQueryKey("backtestsGetBacktest", options);

/**
 * Get Backtest
 * Get backtest by ID
 */
export const backtestsGetBacktestOptions = (
	options: Options<BacktestsGetBacktestData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktest({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestQueryKey(options),
	});
};

/**
 * Update Backtest
 * Update backtest
 */
export const backtestsUpdateBacktestMutation = (
	options?: Partial<Options<BacktestsUpdateBacktestData>>,
): UseMutationOptions<
	BacktestsUpdateBacktestResponse,
	BacktestsUpdateBacktestError,
	Options<BacktestsUpdateBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsUpdateBacktestResponse,
		BacktestsUpdateBacktestError,
		Options<BacktestsUpdateBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.updateBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Execute Backtest
 * Execute backtest with trading signals
 */
export const backtestsExecuteBacktestMutation = (
	options?: Partial<Options<BacktestsExecuteBacktestData>>,
): UseMutationOptions<
	BacktestsExecuteBacktestResponse,
	BacktestsExecuteBacktestError,
	Options<BacktestsExecuteBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsExecuteBacktestResponse,
		BacktestsExecuteBacktestError,
		Options<BacktestsExecuteBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.executeBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsGetBacktestExecutionsQueryKey = (
	options: Options<BacktestsGetBacktestExecutionsData>,
) => createQueryKey("backtestsGetBacktestExecutions", options);

/**
 * Get Backtest Executions
 * Get execution history for a backtest
 */
export const backtestsGetBacktestExecutionsOptions = (
	options: Options<BacktestsGetBacktestExecutionsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktestExecutions({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestExecutionsQueryKey(options),
	});
};

export const backtestsGetBacktestResultsQueryKey = (
	options?: Options<BacktestsGetBacktestResultsData>,
) => createQueryKey("backtestsGetBacktestResults", options);

/**
 * Get Backtest Results
 * Get backtest results from DuckDB (고성능 분석용)
 */
export const backtestsGetBacktestResultsOptions = (
	options?: Options<BacktestsGetBacktestResultsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktestResults({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestResultsQueryKey(options),
	});
};

/**
 * Create And Run Integrated Backtest
 * 통합 백테스트 생성 및 실행 - 모든 서비스 연동
 */
export const backtestsCreateAndRunIntegratedBacktestMutation = (
	options?: Partial<Options<BacktestsCreateAndRunIntegratedBacktestData>>,
): UseMutationOptions<
	BacktestsCreateAndRunIntegratedBacktestResponse,
	BacktestsCreateAndRunIntegratedBacktestError,
	Options<BacktestsCreateAndRunIntegratedBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsCreateAndRunIntegratedBacktestResponse,
		BacktestsCreateAndRunIntegratedBacktestError,
		Options<BacktestsCreateAndRunIntegratedBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.createAndRunIntegratedBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsHealthCheckQueryKey = (
	options?: Options<BacktestsHealthCheckData>,
) => createQueryKey("backtestsHealthCheck", options);

/**
 * Health Check
 * 백테스트 시스템 상태 확인 (DuckDB + MongoDB 통합 상태)
 */
export const backtestsHealthCheckOptions = (
	options?: Options<BacktestsHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.healthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsHealthCheckQueryKey(options),
	});
};

export const backtestsGetPerformanceAnalyticsQueryKey = (
	options?: Options<BacktestsGetPerformanceAnalyticsData>,
) => createQueryKey("backtestsGetPerformanceAnalytics", options);

/**
 * Get Performance Analytics
 * 백테스트 성과 분석 (DuckDB 고성능 분석)
 */
export const backtestsGetPerformanceAnalyticsOptions = (
	options?: Options<BacktestsGetPerformanceAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getPerformanceAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetPerformanceAnalyticsQueryKey(options),
	});
};

export const backtestsGetTradesAnalyticsQueryKey = (
	options?: Options<BacktestsGetTradesAnalyticsData>,
) => createQueryKey("backtestsGetTradesAnalytics", options);

/**
 * Get Trades Analytics
 * 거래 기록 분석 (DuckDB 고성능 쿼리)
 */
export const backtestsGetTradesAnalyticsOptions = (
	options?: Options<BacktestsGetTradesAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getTradesAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetTradesAnalyticsQueryKey(options),
	});
};

export const backtestsGetBacktestSummaryAnalyticsQueryKey = (
	options?: Options<BacktestsGetBacktestSummaryAnalyticsData>,
) => createQueryKey("backtestsGetBacktestSummaryAnalytics", options);

/**
 * Get Backtest Summary Analytics
 * 백테스트 결과 요약 분석 (DuckDB 기반)
 */
export const backtestsGetBacktestSummaryAnalyticsOptions = (
	options?: Options<BacktestsGetBacktestSummaryAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktestSummaryAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestSummaryAnalyticsQueryKey(options),
	});
};
