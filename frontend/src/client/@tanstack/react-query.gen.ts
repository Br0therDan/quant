// This file is auto-generated by @hey-api/openapi-ts

import {
	type DefaultError,
	queryOptions,
	type UseMutationOptions,
} from "@tanstack/react-query";

import { client } from "../client.gen";
import {
	AuthService,
	BacktestsService,
	HealthService,
	MarketDataService,
	type Options,
	PipelineService,
	StrategyService,
	UserService,
} from "../sdk.gen";
import type {
	AuthAuthorizeData,
	AuthCallbackData,
	AuthLoginData,
	AuthLoginError,
	AuthLoginResponse,
	AuthLogoutData,
	AuthLogoutResponse,
	AuthRefreshTokenData,
	AuthRefreshTokenError,
	AuthRefreshTokenResponse,
	AuthRegisterData,
	AuthRegisterError,
	AuthRegisterResponse,
	AuthRequestVerifyTokenData,
	AuthRequestVerifyTokenError,
	AuthResetForgotPasswordData,
	AuthResetForgotPasswordError,
	AuthResetResetPasswordData,
	AuthResetResetPasswordError,
	AuthVerifyData,
	AuthVerifyError,
	AuthVerifyResponse,
	AuthVerifyTokenData,
	BacktestsCreateAndRunIntegratedBacktestData,
	BacktestsCreateAndRunIntegratedBacktestError,
	BacktestsCreateAndRunIntegratedBacktestResponse,
	BacktestsCreateBacktestData,
	BacktestsCreateBacktestError,
	BacktestsCreateBacktestResponse,
	BacktestsDeleteBacktestData,
	BacktestsDeleteBacktestError,
	BacktestsExecuteBacktestData,
	BacktestsExecuteBacktestError,
	BacktestsExecuteBacktestResponse,
	BacktestsGetBacktestData,
	BacktestsGetBacktestExecutionsData,
	BacktestsGetBacktestResultsData,
	BacktestsGetBacktestsData,
	BacktestsGetBacktestSummaryAnalyticsData,
	BacktestsGetPerformanceAnalyticsData,
	BacktestsGetTradesAnalyticsData,
	BacktestsHealthCheckData,
	BacktestsUpdateBacktestData,
	BacktestsUpdateBacktestError,
	BacktestsUpdateBacktestResponse,
	HealthHealthCheckData,
	HealthLivenessProbeData,
	HealthReadinessProbeData,
	MarketDataAnalyzeDataQualityData,
	MarketDataGetAvailableSymbolsData,
	MarketDataGetCachePerformanceStatsData,
	MarketDataGetDataCoverageData,
	MarketDataGetMarketDataData,
	MarketDataGetSymbolsCoverageAnalyticsData,
	MarketDataRequestBulkDataData,
	MarketDataRequestBulkDataError,
	MarketDataRequestBulkDataResponse,
	MarketDataServiceHealthCheckData,
	PipelineCollectDailyDataData,
	PipelineCollectDailyDataError,
	PipelineCollectStockInfoData,
	PipelineCollectStockInfoError,
	PipelineCreateWatchlistData,
	PipelineCreateWatchlistError,
	PipelineDeleteWatchlistData,
	PipelineDeleteWatchlistError,
	PipelineGetCompanyInfoData,
	PipelineGetPipelineStatusData,
	PipelineGetSymbolCoverageData,
	PipelineGetWatchlistData,
	PipelineListCompaniesData,
	PipelineListWatchlistsData,
	PipelineRunPipelineUpdateData,
	PipelineRunPipelineUpdateError,
	PipelineSetupDefaultSymbolsData,
	PipelineUpdateWatchlistByNameData,
	PipelineUpdateWatchlistByNameError,
	PipelineUpdateWatchlistData,
	PipelineUpdateWatchlistError,
	StrategyCreateStrategyData,
	StrategyCreateStrategyError,
	StrategyCreateStrategyFromTemplateData,
	StrategyCreateStrategyFromTemplateError,
	StrategyCreateStrategyFromTemplateResponse,
	StrategyCreateStrategyResponse,
	StrategyCreateTemplateData,
	StrategyCreateTemplateError,
	StrategyCreateTemplateResponse,
	StrategyDeleteStrategyData,
	StrategyDeleteStrategyError,
	StrategyDeleteTemplateData,
	StrategyDeleteTemplateError,
	StrategyExecuteStrategyData,
	StrategyExecuteStrategyError,
	StrategyExecuteStrategyResponse,
	StrategyGetStrategiesData,
	StrategyGetStrategyData,
	StrategyGetStrategyExecutionsData,
	StrategyGetStrategyPerformanceData,
	StrategyGetTemplateData,
	StrategyGetTemplatesData,
	StrategyGetTemplateUsageStatsData,
	StrategyUpdateStrategyData,
	StrategyUpdateStrategyError,
	StrategyUpdateStrategyResponse,
	StrategyUpdateTemplateData,
	StrategyUpdateTemplateError,
	StrategyUpdateTemplateResponse,
	UserDeleteUserData,
	UserDeleteUserError,
	UserDeleteUserResponse,
	UserGetMyOauthAccountsData,
	UserGetUserData,
	UserGetUserMeData,
	UserGetUserOauthAccountsData,
	UserRemoveOauthAccountData,
	UserRemoveOauthAccountError,
	UserRemoveOauthAccountResponse,
	UserUpdateUserData,
	UserUpdateUserError,
	UserUpdateUserMeData,
	UserUpdateUserMeError,
	UserUpdateUserMeResponse,
	UserUpdateUserResponse,
} from "../types.gen";

export type QueryKey<TOptions extends Options> = [
	Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
		_id: string;
		_infinite?: boolean;
		tags?: ReadonlyArray<string>;
	},
];

const createQueryKey = <TOptions extends Options>(
	id: string,
	options?: TOptions,
	infinite?: boolean,
	tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
	const params: QueryKey<TOptions>[0] = {
		_id: id,
		baseUrl:
			options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
	} as QueryKey<TOptions>[0];
	if (infinite) {
		params._infinite = infinite;
	}
	if (tags) {
		params.tags = tags;
	}
	if (options?.body) {
		params.body = options.body;
	}
	if (options?.headers) {
		params.headers = options.headers;
	}
	if (options?.path) {
		params.path = options.path;
	}
	if (options?.query) {
		params.query = options.query;
	}
	return [params];
};

export const healthHealthCheckQueryKey = (
	options?: Options<HealthHealthCheckData>,
) => createQueryKey("healthHealthCheck", options);

/**
 * Health Check
 * Get comprehensive health status.
 */
export const healthHealthCheckOptions = (
	options?: Options<HealthHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.healthHealthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthHealthCheckQueryKey(options),
	});
};

export const healthLivenessProbeQueryKey = (
	options?: Options<HealthLivenessProbeData>,
) => createQueryKey("healthLivenessProbe", options);

/**
 * Liveness Probe
 * Kubernetes liveness probe endpoint.
 */
export const healthLivenessProbeOptions = (
	options?: Options<HealthLivenessProbeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.healthLivenessProbe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthLivenessProbeQueryKey(options),
	});
};

export const healthReadinessProbeQueryKey = (
	options?: Options<HealthReadinessProbeData>,
) => createQueryKey("healthReadinessProbe", options);

/**
 * Readiness Probe
 * Kubernetes readiness probe endpoint.
 */
export const healthReadinessProbeOptions = (
	options?: Options<HealthReadinessProbeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.healthReadinessProbe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthReadinessProbeQueryKey(options),
	});
};

/**
 * Login
 */
export const authLoginMutation = (
	options?: Partial<Options<AuthLoginData>>,
): UseMutationOptions<
	AuthLoginResponse,
	AuthLoginError,
	Options<AuthLoginData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthLoginResponse,
		AuthLoginError,
		Options<AuthLoginData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.authLogin({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Logout
 * 로그아웃 엔드포인트.
 *
 * 쿠키에서 토큰을 삭제하고 로그아웃 처리를 합니다.
 */
export const authLogoutMutation = (
	options?: Partial<Options<AuthLogoutData>>,
): UseMutationOptions<
	AuthLogoutResponse,
	DefaultError,
	Options<AuthLogoutData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthLogoutResponse,
		DefaultError,
		Options<AuthLogoutData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.authLogout({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Refresh Token
 * JWT 토큰 갱신 엔드포인트
 */
export const authRefreshTokenMutation = (
	options?: Partial<Options<AuthRefreshTokenData>>,
): UseMutationOptions<
	AuthRefreshTokenResponse,
	AuthRefreshTokenError,
	Options<AuthRefreshTokenData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthRefreshTokenResponse,
		AuthRefreshTokenError,
		Options<AuthRefreshTokenData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.authRefreshToken({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const authVerifyTokenQueryKey = (
	options?: Options<AuthVerifyTokenData>,
) => createQueryKey("authVerifyToken", options);

/**
 * Verify Token
 * 토큰 검증 및 사용자 정보 반환 (디버깅용)
 */
export const authVerifyTokenOptions = (
	options?: Options<AuthVerifyTokenData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await AuthService.authVerifyToken({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: authVerifyTokenQueryKey(options),
	});
};

/**
 * Register
 */
export const authRegisterMutation = (
	options?: Partial<Options<AuthRegisterData>>,
): UseMutationOptions<
	AuthRegisterResponse,
	AuthRegisterError,
	Options<AuthRegisterData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthRegisterResponse,
		AuthRegisterError,
		Options<AuthRegisterData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.authRegister({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Reset:Forgot Password
 */
export const authResetForgotPasswordMutation = (
	options?: Partial<Options<AuthResetForgotPasswordData>>,
): UseMutationOptions<
	unknown,
	AuthResetForgotPasswordError,
	Options<AuthResetForgotPasswordData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthResetForgotPasswordError,
		Options<AuthResetForgotPasswordData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.authResetForgotPassword({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Reset:Reset Password
 */
export const authResetResetPasswordMutation = (
	options?: Partial<Options<AuthResetResetPasswordData>>,
): UseMutationOptions<
	unknown,
	AuthResetResetPasswordError,
	Options<AuthResetResetPasswordData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthResetResetPasswordError,
		Options<AuthResetResetPasswordData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.authResetResetPassword({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Request Verify Token
 */
export const authRequestVerifyTokenMutation = (
	options?: Partial<Options<AuthRequestVerifyTokenData>>,
): UseMutationOptions<
	unknown,
	AuthRequestVerifyTokenError,
	Options<AuthRequestVerifyTokenData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthRequestVerifyTokenError,
		Options<AuthRequestVerifyTokenData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.authRequestVerifyToken({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Verify
 */
export const authVerifyMutation = (
	options?: Partial<Options<AuthVerifyData>>,
): UseMutationOptions<
	AuthVerifyResponse,
	AuthVerifyError,
	Options<AuthVerifyData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthVerifyResponse,
		AuthVerifyError,
		Options<AuthVerifyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.authVerify({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const authAuthorizeQueryKey = (options: Options<AuthAuthorizeData>) =>
	createQueryKey("authAuthorize", options);

/**
 * Authorize
 * Initiate the OAuth2 authorization process for associating an OAuth account
 * with the currently authenticated user.
 */
export const authAuthorizeOptions = (options: Options<AuthAuthorizeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await AuthService.authAuthorize({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: authAuthorizeQueryKey(options),
	});
};

export const authCallbackQueryKey = (options: Options<AuthCallbackData>) =>
	createQueryKey("authCallback", options);

/**
 * Callback
 * The response varies based on the authentication backend used.
 */
export const authCallbackOptions = (options: Options<AuthCallbackData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await AuthService.authCallback({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: authCallbackQueryKey(options),
	});
};

export const userGetUserMeQueryKey = (options?: Options<UserGetUserMeData>) =>
	createQueryKey("userGetUserMe", options);

/**
 * Get User Me
 */
export const userGetUserMeOptions = (options?: Options<UserGetUserMeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.userGetUserMe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserMeQueryKey(options),
	});
};

/**
 * Update User Me
 */
export const userUpdateUserMeMutation = (
	options?: Partial<Options<UserUpdateUserMeData>>,
): UseMutationOptions<
	UserUpdateUserMeResponse,
	UserUpdateUserMeError,
	Options<UserUpdateUserMeData>
> => {
	const mutationOptions: UseMutationOptions<
		UserUpdateUserMeResponse,
		UserUpdateUserMeError,
		Options<UserUpdateUserMeData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.userUpdateUserMe({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete User
 */
export const userDeleteUserMutation = (
	options?: Partial<Options<UserDeleteUserData>>,
): UseMutationOptions<
	UserDeleteUserResponse,
	UserDeleteUserError,
	Options<UserDeleteUserData>
> => {
	const mutationOptions: UseMutationOptions<
		UserDeleteUserResponse,
		UserDeleteUserError,
		Options<UserDeleteUserData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.userDeleteUser({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserQueryKey = (options: Options<UserGetUserData>) =>
	createQueryKey("userGetUser", options);

/**
 * Get User
 */
export const userGetUserOptions = (options: Options<UserGetUserData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.userGetUser({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserQueryKey(options),
	});
};

/**
 * Update User
 */
export const userUpdateUserMutation = (
	options?: Partial<Options<UserUpdateUserData>>,
): UseMutationOptions<
	UserUpdateUserResponse,
	UserUpdateUserError,
	Options<UserUpdateUserData>
> => {
	const mutationOptions: UseMutationOptions<
		UserUpdateUserResponse,
		UserUpdateUserError,
		Options<UserUpdateUserData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.userUpdateUser({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetMyOauthAccountsQueryKey = (
	options?: Options<UserGetMyOauthAccountsData>,
) => createQueryKey("userGetMyOauthAccounts", options);

/**
 * 내 OAuth 계정 목록 조회
 * 현재 사용자의 연결된 OAuth 계정 목록을 조회합니다.
 */
export const userGetMyOauthAccountsOptions = (
	options?: Options<UserGetMyOauthAccountsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.userGetMyOauthAccounts({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetMyOauthAccountsQueryKey(options),
	});
};

/**
 * OAuth 계정 연결 해제
 * 특정 OAuth 계정 연결을 해제합니다.
 */
export const userRemoveOauthAccountMutation = (
	options?: Partial<Options<UserRemoveOauthAccountData>>,
): UseMutationOptions<
	UserRemoveOauthAccountResponse,
	UserRemoveOauthAccountError,
	Options<UserRemoveOauthAccountData>
> => {
	const mutationOptions: UseMutationOptions<
		UserRemoveOauthAccountResponse,
		UserRemoveOauthAccountError,
		Options<UserRemoveOauthAccountData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.userRemoveOauthAccount({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserOauthAccountsQueryKey = (
	options: Options<UserGetUserOauthAccountsData>,
) => createQueryKey("userGetUserOauthAccounts", options);

/**
 * 사용자 OAuth 계정 목록 조회 (관리자용)
 * 특정 사용자의 OAuth 계정 목록을 조회합니다. (관리자 전용)
 */
export const userGetUserOauthAccountsOptions = (
	options: Options<UserGetUserOauthAccountsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.userGetUserOauthAccounts({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserOauthAccountsQueryKey(options),
	});
};

export const marketDataGetAvailableSymbolsQueryKey = (
	options?: Options<MarketDataGetAvailableSymbolsData>,
) => createQueryKey("marketDataGetAvailableSymbols", options);

/**
 * Get Available Symbols
 * Get list of all available symbols
 */
export const marketDataGetAvailableSymbolsOptions = (
	options?: Options<MarketDataGetAvailableSymbolsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.marketDataGetAvailableSymbols({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetAvailableSymbolsQueryKey(options),
	});
};

export const marketDataGetMarketDataQueryKey = (
	options: Options<MarketDataGetMarketDataData>,
) => createQueryKey("marketDataGetMarketData", options);

/**
 * Get Market Data
 * Get market data for a specific symbol and date range
 */
export const marketDataGetMarketDataOptions = (
	options: Options<MarketDataGetMarketDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.marketDataGetMarketData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetMarketDataQueryKey(options),
	});
};

/**
 * Request Bulk Data
 * Request bulk market data for multiple symbols
 */
export const marketDataRequestBulkDataMutation = (
	options?: Partial<Options<MarketDataRequestBulkDataData>>,
): UseMutationOptions<
	MarketDataRequestBulkDataResponse,
	MarketDataRequestBulkDataError,
	Options<MarketDataRequestBulkDataData>
> => {
	const mutationOptions: UseMutationOptions<
		MarketDataRequestBulkDataResponse,
		MarketDataRequestBulkDataError,
		Options<MarketDataRequestBulkDataData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await MarketDataService.marketDataRequestBulkData({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const marketDataGetDataCoverageQueryKey = (
	options: Options<MarketDataGetDataCoverageData>,
) => createQueryKey("marketDataGetDataCoverage", options);

/**
 * Get Data Coverage
 * Get data coverage information for a symbol
 */
export const marketDataGetDataCoverageOptions = (
	options: Options<MarketDataGetDataCoverageData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.marketDataGetDataCoverage({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetDataCoverageQueryKey(options),
	});
};

export const marketDataAnalyzeDataQualityQueryKey = (
	options: Options<MarketDataAnalyzeDataQualityData>,
) => createQueryKey("marketDataAnalyzeDataQuality", options);

/**
 * Analyze Data Quality
 * Analyze data quality for a symbol and date range
 */
export const marketDataAnalyzeDataQualityOptions = (
	options: Options<MarketDataAnalyzeDataQualityData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.marketDataAnalyzeDataQuality({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataAnalyzeDataQualityQueryKey(options),
	});
};

export const marketDataGetCachePerformanceStatsQueryKey = (
	options?: Options<MarketDataGetCachePerformanceStatsData>,
) => createQueryKey("marketDataGetCachePerformanceStats", options);

/**
 * Get Cache Performance Stats
 * DuckDB 캐시 성능 통계 조회
 */
export const marketDataGetCachePerformanceStatsOptions = (
	options?: Options<MarketDataGetCachePerformanceStatsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } =
				await MarketDataService.marketDataGetCachePerformanceStats({
					...options,
					...queryKey[0],
					signal,
					throwOnError: true,
				});
			return data;
		},
		queryKey: marketDataGetCachePerformanceStatsQueryKey(options),
	});
};

export const marketDataGetSymbolsCoverageAnalyticsQueryKey = (
	options?: Options<MarketDataGetSymbolsCoverageAnalyticsData>,
) => createQueryKey("marketDataGetSymbolsCoverageAnalytics", options);

/**
 * Get Symbols Coverage Analytics
 * 심볼별 데이터 커버리지 분석
 */
export const marketDataGetSymbolsCoverageAnalyticsOptions = (
	options?: Options<MarketDataGetSymbolsCoverageAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } =
				await MarketDataService.marketDataGetSymbolsCoverageAnalytics({
					...options,
					...queryKey[0],
					signal,
					throwOnError: true,
				});
			return data;
		},
		queryKey: marketDataGetSymbolsCoverageAnalyticsQueryKey(options),
	});
};

export const marketDataServiceHealthCheckQueryKey = (
	options?: Options<MarketDataServiceHealthCheckData>,
) => createQueryKey("marketDataServiceHealthCheck", options);

/**
 * Service Health Check
 * Health check endpoint
 */
export const marketDataServiceHealthCheckOptions = (
	options?: Options<MarketDataServiceHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.marketDataServiceHealthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataServiceHealthCheckQueryKey(options),
	});
};

/**
 * Update Watchlist
 * Create or update a watchlist with flexible naming support.
 *
 * This endpoint provides a convenient way to create new watchlists or update
 * existing ones. If no name is provided, it defaults to the 'default' watchlist
 * which is used by the pipeline for automated updates. This endpoint combines
 * creation and update functionality for ease of use.
 *
 * Args:
 * request: Watchlist configuration containing:
 * - symbols: List of stock symbols to include
 * - name: Optional watchlist name (defaults to 'default')
 * - description: Optional description of the watchlist
 *
 * Returns:
 * dict: Operation result containing:
 * - message: Success message indicating action taken
 * - name: Watchlist name that was processed
 * - symbols: List of symbols in the watchlist
 * - count: Number of symbols in the watchlist
 * - action: Either 'created' or 'updated'
 *
 * Raises:
 * HTTPException: 400 if watchlist creation fails
 * HTTPException: 500 if operation fails
 *
 * Note:
 * Updates to the 'default' watchlist automatically update pipeline symbols.
 * This affects which symbols are processed during automated updates.
 */
export const pipelineUpdateWatchlistMutation = (
	options?: Partial<Options<PipelineUpdateWatchlistData>>,
): UseMutationOptions<
	unknown,
	PipelineUpdateWatchlistError,
	Options<PipelineUpdateWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineUpdateWatchlistError,
		Options<PipelineUpdateWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.pipelineUpdateWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const pipelineListWatchlistsQueryKey = (
	options?: Options<PipelineListWatchlistsData>,
) => createQueryKey("pipelineListWatchlists", options);

/**
 * List Watchlists
 * Retrieve a comprehensive list of all watchlists.
 *
 * Returns summary information for all watchlists in the system, including
 * metadata like symbol counts, update settings, and timestamps. This is
 * useful for dashboard displays and watchlist management interfaces.
 *
 * Returns:
 * dict: All watchlists summary containing:
 * - watchlists: List of watchlist summaries with:
 * - name: Watchlist name
 * - description: Watchlist description
 * - symbol_count: Number of symbols in the watchlist
 * - auto_update: Whether automatic updates are enabled
 * - last_updated: Timestamp of last modification
 * - created_at: Timestamp of creation
 * - total_count: Total number of watchlists in the system
 *
 * Raises:
 * HTTPException: 500 if retrieval fails
 *
 * Note:
 * This endpoint returns summary data only. Use GET /watchlists/{name}
 * for detailed information including full symbol lists.
 */
export const pipelineListWatchlistsOptions = (
	options?: Options<PipelineListWatchlistsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.pipelineListWatchlists({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineListWatchlistsQueryKey(options),
	});
};

/**
 * Create Watchlist
 * Create a new named watchlist with validation.
 *
 * This endpoint is specifically for creating new watchlists with explicit
 * naming requirements. Unlike the /watchlist endpoint, this requires a name
 * and will fail if a watchlist with the same name already exists.
 *
 * Args:
 * request: Watchlist creation parameters containing:
 * - name: Required unique name for the watchlist
 * - symbols: List of stock symbols to include
 * - description: Optional description of the watchlist purpose
 *
 * Returns:
 * dict: Creation result containing:
 * - message: Success confirmation message
 * - name: Name of the created watchlist
 * - symbols: List of symbols in the watchlist
 * - description: Watchlist description
 * - created_at: UTC timestamp of creation
 *
 * Raises:
 * HTTPException: 400 if watchlist creation fails or name conflicts
 * HTTPException: 500 if database operation fails
 *
 * Note:
 * Watchlist names must be unique. Use PUT /watchlists/{name} to update existing ones.
 */
export const pipelineCreateWatchlistMutation = (
	options?: Partial<Options<PipelineCreateWatchlistData>>,
): UseMutationOptions<
	unknown,
	PipelineCreateWatchlistError,
	Options<PipelineCreateWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineCreateWatchlistError,
		Options<PipelineCreateWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.pipelineCreateWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Watchlist
 * Delete a named watchlist from the system.
 *
 * Permanently removes a watchlist and all associated metadata. This action
 * cannot be undone. The 'default' watchlist cannot be deleted as it is
 * required for pipeline operations.
 *
 * Args:
 * name: Name of the watchlist to delete
 *
 * Returns:
 * dict: Deletion confirmation containing:
 * - message: Success confirmation message
 * - name: Name of the deleted watchlist
 *
 * Raises:
 * HTTPException: 400 if attempting to delete the 'default' watchlist
 * HTTPException: 404 if watchlist with specified name not found
 * HTTPException: 500 if deletion operation fails
 *
 * Note:
 * Deletion is permanent and cannot be undone. Consider backing up
 * important watchlists before deletion.
 */
export const pipelineDeleteWatchlistMutation = (
	options?: Partial<Options<PipelineDeleteWatchlistData>>,
): UseMutationOptions<
	unknown,
	PipelineDeleteWatchlistError,
	Options<PipelineDeleteWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineDeleteWatchlistError,
		Options<PipelineDeleteWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.pipelineDeleteWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const pipelineGetWatchlistQueryKey = (
	options: Options<PipelineGetWatchlistData>,
) => createQueryKey("pipelineGetWatchlist", options);

/**
 * Get Watchlist
 * Retrieve complete information for a specific watchlist.
 *
 * Returns detailed information about a named watchlist including the full
 * list of symbols, configuration settings, and all metadata. This provides
 * all information needed to display or modify a specific watchlist.
 *
 * Args:
 * name: Name of the watchlist to retrieve (case-sensitive)
 *
 * Returns:
 * dict: Complete watchlist information containing:
 * - name: Watchlist name
 * - description: Detailed description
 * - symbols: Complete list of stock symbols
 * - auto_update: Automatic update configuration
 * - update_interval: Update frequency in seconds
 * - last_updated: Timestamp of last symbol update
 * - created_at: Timestamp of watchlist creation
 *
 * Raises:
 * HTTPException: 404 if watchlist with specified name not found
 * HTTPException: 500 if retrieval operation fails
 *
 * Note:
 * Watchlist names are case-sensitive. Use GET /watchlists to see all available names.
 */
export const pipelineGetWatchlistOptions = (
	options: Options<PipelineGetWatchlistData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.pipelineGetWatchlist({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineGetWatchlistQueryKey(options),
	});
};

/**
 * Update Watchlist By Name
 * Update an existing watchlist with new symbols and settings.
 *
 * Modifies the symbols and metadata of an existing watchlist. This endpoint
 * requires the watchlist to exist and will fail if the specified name is
 * not found. Use POST /watchlists to create new watchlists.
 *
 * Args:
 * name: Name of the existing watchlist to update
 * request: Update parameters containing:
 * - symbols: New list of symbols (replaces current list)
 * - description: Optional new description (if provided)
 *
 * Returns:
 * dict: Update confirmation containing:
 * - message: Success confirmation message
 * - name: Name of the updated watchlist
 * - symbols: New symbols list
 * - description: Current description (updated if provided)
 * - count: Number of symbols in updated watchlist
 * - updated_at: Timestamp of the update
 *
 * Raises:
 * HTTPException: 404 if watchlist with specified name not found
 * HTTPException: 500 if update operation fails
 *
 * Note:
 * Updates to the 'default' watchlist automatically update pipeline symbols.
 * Symbol list is completely replaced, not merged with existing symbols.
 */
export const pipelineUpdateWatchlistByNameMutation = (
	options?: Partial<Options<PipelineUpdateWatchlistByNameData>>,
): UseMutationOptions<
	unknown,
	PipelineUpdateWatchlistByNameError,
	Options<PipelineUpdateWatchlistByNameData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineUpdateWatchlistByNameError,
		Options<PipelineUpdateWatchlistByNameData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.pipelineUpdateWatchlistByName({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Collect Stock Info
 * Collect and store basic company information for a specific symbol.
 *
 * Retrieves fundamental company data from external APIs (Alpha Vantage)
 * including company name, sector, industry, market cap, and key financial
 * ratios. This information is stored in the database for future reference
 * and analysis.
 *
 * Args:
 * symbol: Stock symbol (e.g., 'AAPL', 'MSFT') - automatically converted to uppercase
 *
 * Returns:
 * dict: Collection result containing:
 * - message: Success/failure message
 * - symbol: Processed symbol (uppercase)
 * - success: Boolean indicating operation success
 *
 * Raises:
 * HTTPException: 500 if data collection fails
 *
 * Note:
 * Respects Alpha Vantage API rate limits (5 calls/min, 500 calls/day).
 * Duplicate requests for same symbol within 24 hours may return cached data.
 */
export const pipelineCollectStockInfoMutation = (
	options?: Partial<Options<PipelineCollectStockInfoData>>,
): UseMutationOptions<
	unknown,
	PipelineCollectStockInfoError,
	Options<PipelineCollectStockInfoData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineCollectStockInfoError,
		Options<PipelineCollectStockInfoData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.pipelineCollectStockInfo({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Collect Daily Data
 * Collect historical daily price data for a specific symbol.
 *
 * Retrieves OHLCV (Open, High, Low, Close, Volume) daily price data
 * for the specified symbol and date range. If no dates are provided,
 * collects maximum available historical data. Data is validated,
 * adjusted for splits/dividends, and stored in DuckDB for fast access.
 *
 * Args:
 * symbol: Stock symbol (e.g., 'AAPL') - automatically converted to uppercase
 * start_date: Optional start date for data collection (defaults to earliest available)
 * end_date: Optional end date for data collection (defaults to latest available)
 *
 * Returns:
 * dict: Collection result containing:
 * - message: Detailed success/failure message
 * - symbol: Processed symbol (uppercase)
 * - start_date: Actual start date used
 * - end_date: Actual end date used
 * - success: Boolean indicating operation success
 *
 * Raises:
 * HTTPException: 500 if data collection fails
 *
 * Note:
 * Large date ranges may take several minutes to complete.
 * Data is automatically cached to minimize API calls.
 */
export const pipelineCollectDailyDataMutation = (
	options?: Partial<Options<PipelineCollectDailyDataData>>,
): UseMutationOptions<
	unknown,
	PipelineCollectDailyDataError,
	Options<PipelineCollectDailyDataData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineCollectDailyDataError,
		Options<PipelineCollectDailyDataData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.pipelineCollectDailyData({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const pipelineGetSymbolCoverageQueryKey = (
	options: Options<PipelineGetSymbolCoverageData>,
) => createQueryKey("pipelineGetSymbolCoverage", options);

/**
 * Get Symbol Coverage
 * Get detailed data coverage information for a specific symbol.
 *
 * Returns comprehensive information about the availability and quality
 * of data for the specified symbol, including date ranges, data gaps,
 * last update timestamps, and data quality metrics.
 *
 * Args:
 * symbol: Stock symbol to check coverage for (automatically converted to uppercase)
 *
 * Returns:
 * dict: Coverage information containing:
 * - symbol: Processed symbol
 * - date_range: Start and end dates of available data
 * - total_records: Number of data points available
 * - gaps: List of date ranges with missing data
 * - last_updated: Timestamp of most recent data update
 * - data_quality: Quality metrics (completeness, accuracy scores)
 *
 * Raises:
 * HTTPException: 500 if coverage check fails
 * HTTPException: 404 if symbol not found in database
 */
export const pipelineGetSymbolCoverageOptions = (
	options: Options<PipelineGetSymbolCoverageData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.pipelineGetSymbolCoverage({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineGetSymbolCoverageQueryKey(options),
	});
};

export const pipelineGetCompanyInfoQueryKey = (
	options: Options<PipelineGetCompanyInfoData>,
) => createQueryKey("pipelineGetCompanyInfo", options);

/**
 * Get Company Info
 * Retrieve stored company information for a specific symbol.
 *
 * Returns comprehensive company fundamentals and metadata previously
 * collected and stored in the database. This includes financial ratios,
 * company description, sector classification, and market data.
 *
 * Args:
 * symbol: Stock symbol (automatically converted to uppercase)
 *
 * Returns:
 * dict: Company information containing:
 * - symbol: Stock symbol
 * - name: Company name
 * - description: Business description
 * - sector: Industry sector classification
 * - industry: Specific industry classification
 * - country: Country of incorporation
 * - currency: Reporting currency
 * - market_cap: Market capitalization (if available)
 * - pe_ratio: Price-to-earnings ratio (if available)
 * - dividend_yield: Annual dividend yield (if available)
 * - updated_at: Last information update timestamp
 *
 * Raises:
 * HTTPException: 404 if company information not found
 * HTTPException: 500 if retrieval fails
 *
 * Note:
 * If company info not found, use POST /collect-info/{symbol} first.
 */
export const pipelineGetCompanyInfoOptions = (
	options: Options<PipelineGetCompanyInfoData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.pipelineGetCompanyInfo({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineGetCompanyInfoQueryKey(options),
	});
};

export const pipelineListCompaniesQueryKey = (
	options?: Options<PipelineListCompaniesData>,
) => createQueryKey("pipelineListCompanies", options);

/**
 * List Companies
 * Retrieve information for all companies in the database.
 *
 * Returns a comprehensive list of all companies for which information
 * has been collected and stored. Useful for portfolio analysis,
 * screening, and getting an overview of available data.
 *
 * Returns:
 * dict: All companies data containing:
 * - companies: List of company objects with key information:
 * - symbol: Stock symbol
 * - name: Company name
 * - sector: Industry sector
 * - industry: Specific industry
 * - market_cap: Market capitalization
 * - updated_at: Last update timestamp
 * - total_count: Total number of companies in database
 *
 * Raises:
 * HTTPException: 500 if retrieval fails
 *
 * Note:
 * Large datasets may take time to load. Consider pagination for production use.
 */
export const pipelineListCompaniesOptions = (
	options?: Options<PipelineListCompaniesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.pipelineListCompanies({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineListCompaniesQueryKey(options),
	});
};

export const pipelineGetPipelineStatusQueryKey = (
	options?: Options<PipelineGetPipelineStatusData>,
) => createQueryKey("pipelineGetPipelineStatus", options);

/**
 * Get Pipeline Status
 * Get comprehensive pipeline status and health information.
 *
 * Returns detailed information about the current state of the data pipeline,
 * including data coverage statistics, update timestamps, and system health metrics.
 * This endpoint is essential for monitoring the overall health of the data
 * collection and processing system.
 *
 * Returns:
 * dict: Pipeline status containing:
 * - overall_status: Current pipeline health status
 * - last_update: Timestamp of last successful update
 * - coverage_stats: Data coverage statistics per symbol
 * - active_symbols: Currently monitored symbols count
 * - error_count: Number of recent errors
 *
 * Raises:
 * HTTPException: 500 if status retrieval fails
 */
export const pipelineGetPipelineStatusOptions = (
	options?: Options<PipelineGetPipelineStatusData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await PipelineService.pipelineGetPipelineStatus({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: pipelineGetPipelineStatusQueryKey(options),
	});
};

/**
 * Setup Default Symbols
 * Initialize default watchlist with standard symbols.
 *
 * Sets up the pipeline with a predefined set of popular stock symbols
 * for immediate use. This is typically called during initial system setup
 * or when resetting the pipeline to defaults. Creates the 'default' watchlist
 * if it doesn't exist.
 *
 * Default symbols include major tech stocks: AAPL, MSFT, GOOGL, AMZN, etc.
 *
 * Returns:
 * dict: Setup confirmation containing:
 * - message: Success confirmation message
 * - symbols: List of symbols that were set up
 *
 * Raises:
 * HTTPException: 500 if default setup fails
 */
export const pipelineSetupDefaultSymbolsMutation = (
	options?: Partial<Options<PipelineSetupDefaultSymbolsData>>,
): UseMutationOptions<
	unknown,
	DefaultError,
	Options<PipelineSetupDefaultSymbolsData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		DefaultError,
		Options<PipelineSetupDefaultSymbolsData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.pipelineSetupDefaultSymbols({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Run Pipeline Update
 * Execute comprehensive data pipeline update for specified symbols.
 *
 * Initiates a full data collection and update process for the specified
 * symbols or the default watchlist. The update runs asynchronously in the
 * background to avoid blocking the API response. Includes company information
 * retrieval, historical price data collection, and data validation.
 *
 * Args:
 * request: Update configuration containing:
 * - symbols: Optional list of symbols to update (uses default if None)
 * - start_date: Optional start date for data collection
 * - end_date: Optional end date for data collection
 * background_tasks: FastAPI background task manager
 *
 * Returns:
 * dict: Update initiation confirmation containing:
 * - message: Update start confirmation
 * - symbols: Symbols being updated
 * - started_at: UTC timestamp when update began
 *
 * Raises:
 * HTTPException: 500 if update initiation fails
 *
 * Note:
 * This is an asynchronous operation. Use /status endpoint to monitor progress.
 */
export const pipelineRunPipelineUpdateMutation = (
	options?: Partial<Options<PipelineRunPipelineUpdateData>>,
): UseMutationOptions<
	unknown,
	PipelineRunPipelineUpdateError,
	Options<PipelineRunPipelineUpdateData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		PipelineRunPipelineUpdateError,
		Options<PipelineRunPipelineUpdateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await PipelineService.pipelineRunPipelineUpdate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetStrategiesQueryKey = (
	options?: Options<StrategyGetStrategiesData>,
) => createQueryKey("strategyGetStrategies", options);

/**
 * Get Strategies
 * Get list of strategies
 */
export const strategyGetStrategiesOptions = (
	options?: Options<StrategyGetStrategiesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.strategyGetStrategies({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategiesQueryKey(options),
	});
};

/**
 * Create Strategy
 * Create a new strategy
 */
export const strategyCreateStrategyMutation = (
	options?: Partial<Options<StrategyCreateStrategyData>>,
): UseMutationOptions<
	StrategyCreateStrategyResponse,
	StrategyCreateStrategyError,
	Options<StrategyCreateStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateStrategyResponse,
		StrategyCreateStrategyError,
		Options<StrategyCreateStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.strategyCreateStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Strategy
 * Delete strategy (soft delete)
 */
export const strategyDeleteStrategyMutation = (
	options?: Partial<Options<StrategyDeleteStrategyData>>,
): UseMutationOptions<
	unknown,
	StrategyDeleteStrategyError,
	Options<StrategyDeleteStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		StrategyDeleteStrategyError,
		Options<StrategyDeleteStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.strategyDeleteStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetStrategyQueryKey = (
	options: Options<StrategyGetStrategyData>,
) => createQueryKey("strategyGetStrategy", options);

/**
 * Get Strategy
 * Get strategy by ID
 */
export const strategyGetStrategyOptions = (
	options: Options<StrategyGetStrategyData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.strategyGetStrategy({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyQueryKey(options),
	});
};

/**
 * Update Strategy
 * Update strategy
 */
export const strategyUpdateStrategyMutation = (
	options?: Partial<Options<StrategyUpdateStrategyData>>,
): UseMutationOptions<
	StrategyUpdateStrategyResponse,
	StrategyUpdateStrategyError,
	Options<StrategyUpdateStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyUpdateStrategyResponse,
		StrategyUpdateStrategyError,
		Options<StrategyUpdateStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.strategyUpdateStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Execute Strategy
 * Execute strategy and generate signal
 */
export const strategyExecuteStrategyMutation = (
	options?: Partial<Options<StrategyExecuteStrategyData>>,
): UseMutationOptions<
	StrategyExecuteStrategyResponse,
	StrategyExecuteStrategyError,
	Options<StrategyExecuteStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyExecuteStrategyResponse,
		StrategyExecuteStrategyError,
		Options<StrategyExecuteStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.strategyExecuteStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetStrategyExecutionsQueryKey = (
	options: Options<StrategyGetStrategyExecutionsData>,
) => createQueryKey("strategyGetStrategyExecutions", options);

/**
 * Get Strategy Executions
 * Get strategy execution history
 */
export const strategyGetStrategyExecutionsOptions = (
	options: Options<StrategyGetStrategyExecutionsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.strategyGetStrategyExecutions({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyExecutionsQueryKey(options),
	});
};

export const strategyGetStrategyPerformanceQueryKey = (
	options: Options<StrategyGetStrategyPerformanceData>,
) => createQueryKey("strategyGetStrategyPerformance", options);

/**
 * Get Strategy Performance
 * Get strategy performance metrics
 */
export const strategyGetStrategyPerformanceOptions = (
	options: Options<StrategyGetStrategyPerformanceData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.strategyGetStrategyPerformance({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyPerformanceQueryKey(options),
	});
};

export const strategyGetTemplatesQueryKey = (
	options?: Options<StrategyGetTemplatesData>,
) => createQueryKey("strategyGetTemplates", options);

/**
 * Get Templates
 * Get list of strategy templates
 */
export const strategyGetTemplatesOptions = (
	options?: Options<StrategyGetTemplatesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.strategyGetTemplates({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplatesQueryKey(options),
	});
};

/**
 * Create Template
 * Create a new strategy template (Superuser only)
 */
export const strategyCreateTemplateMutation = (
	options?: Partial<Options<StrategyCreateTemplateData>>,
): UseMutationOptions<
	StrategyCreateTemplateResponse,
	StrategyCreateTemplateError,
	Options<StrategyCreateTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateTemplateResponse,
		StrategyCreateTemplateError,
		Options<StrategyCreateTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.strategyCreateTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Template
 * Delete template by ID (Superuser only)
 */
export const strategyDeleteTemplateMutation = (
	options?: Partial<Options<StrategyDeleteTemplateData>>,
): UseMutationOptions<
	unknown,
	StrategyDeleteTemplateError,
	Options<StrategyDeleteTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		StrategyDeleteTemplateError,
		Options<StrategyDeleteTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.strategyDeleteTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetTemplateQueryKey = (
	options: Options<StrategyGetTemplateData>,
) => createQueryKey("strategyGetTemplate", options);

/**
 * Get Template
 * Get template by ID
 */
export const strategyGetTemplateOptions = (
	options: Options<StrategyGetTemplateData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.strategyGetTemplate({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplateQueryKey(options),
	});
};

/**
 * Update Template
 * Update template by ID (Superuser only)
 */
export const strategyUpdateTemplateMutation = (
	options?: Partial<Options<StrategyUpdateTemplateData>>,
): UseMutationOptions<
	StrategyUpdateTemplateResponse,
	StrategyUpdateTemplateError,
	Options<StrategyUpdateTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyUpdateTemplateResponse,
		StrategyUpdateTemplateError,
		Options<StrategyUpdateTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.strategyUpdateTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Create Strategy From Template
 * Create a strategy instance from template
 */
export const strategyCreateStrategyFromTemplateMutation = (
	options?: Partial<Options<StrategyCreateStrategyFromTemplateData>>,
): UseMutationOptions<
	StrategyCreateStrategyFromTemplateResponse,
	StrategyCreateStrategyFromTemplateError,
	Options<StrategyCreateStrategyFromTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateStrategyFromTemplateResponse,
		StrategyCreateStrategyFromTemplateError,
		Options<StrategyCreateStrategyFromTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.strategyCreateStrategyFromTemplate(
				{
					...options,
					...fnOptions,
					throwOnError: true,
				},
			);
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetTemplateUsageStatsQueryKey = (
	options?: Options<StrategyGetTemplateUsageStatsData>,
) => createQueryKey("strategyGetTemplateUsageStats", options);

/**
 * Get Template Usage Stats
 * Get template usage statistics
 */
export const strategyGetTemplateUsageStatsOptions = (
	options?: Options<StrategyGetTemplateUsageStatsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.strategyGetTemplateUsageStats({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplateUsageStatsQueryKey(options),
	});
};

export const backtestsGetBacktestsQueryKey = (
	options?: Options<BacktestsGetBacktestsData>,
) => createQueryKey("backtestsGetBacktests", options);

/**
 * Get Backtests
 * Get list of backtests
 */
export const backtestsGetBacktestsOptions = (
	options?: Options<BacktestsGetBacktestsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.backtestsGetBacktests({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestsQueryKey(options),
	});
};

/**
 * Create Backtest
 * Create a new backtest
 */
export const backtestsCreateBacktestMutation = (
	options?: Partial<Options<BacktestsCreateBacktestData>>,
): UseMutationOptions<
	BacktestsCreateBacktestResponse,
	BacktestsCreateBacktestError,
	Options<BacktestsCreateBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsCreateBacktestResponse,
		BacktestsCreateBacktestError,
		Options<BacktestsCreateBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.backtestsCreateBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Backtest
 * Delete backtest
 */
export const backtestsDeleteBacktestMutation = (
	options?: Partial<Options<BacktestsDeleteBacktestData>>,
): UseMutationOptions<
	unknown,
	BacktestsDeleteBacktestError,
	Options<BacktestsDeleteBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		BacktestsDeleteBacktestError,
		Options<BacktestsDeleteBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.backtestsDeleteBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsGetBacktestQueryKey = (
	options: Options<BacktestsGetBacktestData>,
) => createQueryKey("backtestsGetBacktest", options);

/**
 * Get Backtest
 * Get backtest by ID
 */
export const backtestsGetBacktestOptions = (
	options: Options<BacktestsGetBacktestData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.backtestsGetBacktest({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestQueryKey(options),
	});
};

/**
 * Update Backtest
 * Update backtest
 */
export const backtestsUpdateBacktestMutation = (
	options?: Partial<Options<BacktestsUpdateBacktestData>>,
): UseMutationOptions<
	BacktestsUpdateBacktestResponse,
	BacktestsUpdateBacktestError,
	Options<BacktestsUpdateBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsUpdateBacktestResponse,
		BacktestsUpdateBacktestError,
		Options<BacktestsUpdateBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.backtestsUpdateBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Execute Backtest
 * Execute backtest with trading signals
 */
export const backtestsExecuteBacktestMutation = (
	options?: Partial<Options<BacktestsExecuteBacktestData>>,
): UseMutationOptions<
	BacktestsExecuteBacktestResponse,
	BacktestsExecuteBacktestError,
	Options<BacktestsExecuteBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsExecuteBacktestResponse,
		BacktestsExecuteBacktestError,
		Options<BacktestsExecuteBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.backtestsExecuteBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsGetBacktestExecutionsQueryKey = (
	options: Options<BacktestsGetBacktestExecutionsData>,
) => createQueryKey("backtestsGetBacktestExecutions", options);

/**
 * Get Backtest Executions
 * Get execution history for a backtest
 */
export const backtestsGetBacktestExecutionsOptions = (
	options: Options<BacktestsGetBacktestExecutionsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.backtestsGetBacktestExecutions({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestExecutionsQueryKey(options),
	});
};

export const backtestsGetBacktestResultsQueryKey = (
	options?: Options<BacktestsGetBacktestResultsData>,
) => createQueryKey("backtestsGetBacktestResults", options);

/**
 * Get Backtest Results
 * Get backtest results from DuckDB (고성능 분석용)
 */
export const backtestsGetBacktestResultsOptions = (
	options?: Options<BacktestsGetBacktestResultsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.backtestsGetBacktestResults({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestResultsQueryKey(options),
	});
};

/**
 * Create And Run Integrated Backtest
 * 통합 백테스트 생성 및 실행 - 모든 서비스 연동
 */
export const backtestsCreateAndRunIntegratedBacktestMutation = (
	options?: Partial<Options<BacktestsCreateAndRunIntegratedBacktestData>>,
): UseMutationOptions<
	BacktestsCreateAndRunIntegratedBacktestResponse,
	BacktestsCreateAndRunIntegratedBacktestError,
	Options<BacktestsCreateAndRunIntegratedBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsCreateAndRunIntegratedBacktestResponse,
		BacktestsCreateAndRunIntegratedBacktestError,
		Options<BacktestsCreateAndRunIntegratedBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } =
				await BacktestsService.backtestsCreateAndRunIntegratedBacktest({
					...options,
					...fnOptions,
					throwOnError: true,
				});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsHealthCheckQueryKey = (
	options?: Options<BacktestsHealthCheckData>,
) => createQueryKey("backtestsHealthCheck", options);

/**
 * Health Check
 * 백테스트 시스템 상태 확인 (DuckDB + MongoDB 통합 상태)
 */
export const backtestsHealthCheckOptions = (
	options?: Options<BacktestsHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.backtestsHealthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsHealthCheckQueryKey(options),
	});
};

export const backtestsGetPerformanceAnalyticsQueryKey = (
	options?: Options<BacktestsGetPerformanceAnalyticsData>,
) => createQueryKey("backtestsGetPerformanceAnalytics", options);

/**
 * Get Performance Analytics
 * 백테스트 성과 분석 (DuckDB 고성능 분석)
 */
export const backtestsGetPerformanceAnalyticsOptions = (
	options?: Options<BacktestsGetPerformanceAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.backtestsGetPerformanceAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetPerformanceAnalyticsQueryKey(options),
	});
};

export const backtestsGetTradesAnalyticsQueryKey = (
	options?: Options<BacktestsGetTradesAnalyticsData>,
) => createQueryKey("backtestsGetTradesAnalytics", options);

/**
 * Get Trades Analytics
 * 거래 기록 분석 (DuckDB 고성능 쿼리)
 */
export const backtestsGetTradesAnalyticsOptions = (
	options?: Options<BacktestsGetTradesAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.backtestsGetTradesAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetTradesAnalyticsQueryKey(options),
	});
};

export const backtestsGetBacktestSummaryAnalyticsQueryKey = (
	options?: Options<BacktestsGetBacktestSummaryAnalyticsData>,
) => createQueryKey("backtestsGetBacktestSummaryAnalytics", options);

/**
 * Get Backtest Summary Analytics
 * 백테스트 결과 요약 분석 (DuckDB 기반)
 */
export const backtestsGetBacktestSummaryAnalyticsOptions = (
	options?: Options<BacktestsGetBacktestSummaryAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } =
				await BacktestsService.backtestsGetBacktestSummaryAnalytics({
					...options,
					...queryKey[0],
					signal,
					throwOnError: true,
				});
			return data;
		},
		queryKey: backtestsGetBacktestSummaryAnalyticsQueryKey(options),
	});
};
