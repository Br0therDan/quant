// This file is auto-generated by @hey-api/openapi-ts

import { queryOptions, type UseMutationOptions } from "@tanstack/react-query";

import { client } from "../client.gen";
import {
	AuthService,
	BacktestsService,
	HealthService,
	MarketDataService,
	OAuth2Service,
	type Options,
	StrategyService,
	UserService,
	WatchlistsService,
} from "../sdk.gen";
import type {
	AuthForgotPasswordData,
	AuthForgotPasswordError,
	AuthLoginData,
	AuthLoginError,
	AuthLoginResponse,
	AuthLogoutData,
	AuthLogoutError,
	AuthLogoutResponse,
	AuthRefreshTokenData,
	AuthRefreshTokenError,
	AuthRefreshTokenResponse,
	AuthRegisterData,
	AuthRegisterError,
	AuthRegisterResponse,
	AuthRequestVerifyTokenData,
	AuthRequestVerifyTokenError,
	AuthResetPasswordData,
	AuthResetPasswordError,
	AuthVerifyData,
	AuthVerifyError,
	AuthVerifyResponse,
	AuthVerifyTokenData,
	BacktestsCreateAndRunIntegratedBacktestData,
	BacktestsCreateAndRunIntegratedBacktestError,
	BacktestsCreateAndRunIntegratedBacktestResponse,
	BacktestsCreateBacktestData,
	BacktestsCreateBacktestError,
	BacktestsCreateBacktestResponse,
	BacktestsDeleteBacktestData,
	BacktestsDeleteBacktestError,
	BacktestsExecuteBacktestData,
	BacktestsExecuteBacktestError,
	BacktestsExecuteBacktestResponse,
	BacktestsGetBacktestData,
	BacktestsGetBacktestExecutionsData,
	BacktestsGetBacktestResultsData,
	BacktestsGetBacktestsData,
	BacktestsGetBacktestSummaryAnalyticsData,
	BacktestsGetPerformanceAnalyticsData,
	BacktestsGetTradesAnalyticsData,
	BacktestsHealthCheckData,
	BacktestsUpdateBacktestData,
	BacktestsUpdateBacktestError,
	BacktestsUpdateBacktestResponse,
	HealthHealthCheckData,
	HealthLivenessProbeData,
	HealthReadinessProbeData,
	MarketDataCollectBulkDataData,
	MarketDataCollectBulkDataError,
	MarketDataCollectCompanyInfoData,
	MarketDataCollectCompanyInfoError,
	MarketDataCollectMarketDataData,
	MarketDataCollectMarketDataError,
	MarketDataGetAnalystRecommendationsData,
	MarketDataGetBalanceSheetData,
	MarketDataGetCashFlowData,
	MarketDataGetCompanyOverviewData,
	MarketDataGetConsumerSentimentData,
	MarketDataGetDailyPricesData,
	MarketDataGetDataCoverageData,
	MarketDataGetEarningsData,
	MarketDataGetEmploymentDataData,
	MarketDataGetGdpDataData,
	MarketDataGetHistoricalDataData,
	MarketDataGetIncomeStatementData,
	MarketDataGetInflationDataData,
	MarketDataGetInterestRatesData,
	MarketDataGetIntradayDataData,
	MarketDataGetMarketDataInfoData,
	MarketDataGetNewsData,
	MarketDataGetQuoteData,
	MarketDataGetSentimentAnalysisData,
	MarketDataGetSocialSentimentData,
	MarketDataGetSystemStatusData,
	MarketDataHealthCheckData,
	OAuth2AuthorizeData,
	OAuth2CallbackData,
	StrategyCreateStrategyData,
	StrategyCreateStrategyError,
	StrategyCreateStrategyFromTemplateData,
	StrategyCreateStrategyFromTemplateError,
	StrategyCreateStrategyFromTemplateResponse,
	StrategyCreateStrategyResponse,
	StrategyCreateTemplateData,
	StrategyCreateTemplateError,
	StrategyCreateTemplateResponse,
	StrategyDeleteStrategyData,
	StrategyDeleteStrategyError,
	StrategyDeleteTemplateData,
	StrategyDeleteTemplateError,
	StrategyExecuteStrategyData,
	StrategyExecuteStrategyError,
	StrategyExecuteStrategyResponse,
	StrategyGetStrategiesData,
	StrategyGetStrategyData,
	StrategyGetStrategyExecutionsData,
	StrategyGetStrategyPerformanceData,
	StrategyGetTemplateData,
	StrategyGetTemplatesData,
	StrategyGetTemplateUsageStatsData,
	StrategyUpdateStrategyData,
	StrategyUpdateStrategyError,
	StrategyUpdateStrategyResponse,
	StrategyUpdateTemplateData,
	StrategyUpdateTemplateError,
	StrategyUpdateTemplateResponse,
	UserDeleteUserData,
	UserDeleteUserError,
	UserDeleteUserResponse,
	UserGetMyOauthAccountsData,
	UserGetUserData,
	UserGetUserMeData,
	UserGetUserOauthAccountsData,
	UserRemoveOauthAccountData,
	UserRemoveOauthAccountError,
	UserRemoveOauthAccountResponse,
	UserUpdateUserData,
	UserUpdateUserError,
	UserUpdateUserMeData,
	UserUpdateUserMeError,
	UserUpdateUserMeResponse,
	UserUpdateUserResponse,
	WatchlistsCreateOrUpdateWatchlistData,
	WatchlistsCreateOrUpdateWatchlistError,
	WatchlistsCreateWatchlistData,
	WatchlistsCreateWatchlistError,
	WatchlistsDeleteWatchlistData,
	WatchlistsDeleteWatchlistError,
	WatchlistsGetWatchlistCoverageData,
	WatchlistsGetWatchlistData,
	WatchlistsListWatchlistsData,
	WatchlistsSetupDefaultWatchlistData,
	WatchlistsSetupDefaultWatchlistError,
	WatchlistsUpdateWatchlistData,
	WatchlistsUpdateWatchlistError,
} from "../types.gen";

export type QueryKey<TOptions extends Options> = [
	Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
		_id: string;
		_infinite?: boolean;
		tags?: ReadonlyArray<string>;
	},
];

const createQueryKey = <TOptions extends Options>(
	id: string,
	options?: TOptions,
	infinite?: boolean,
	tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
	const params: QueryKey<TOptions>[0] = {
		_id: id,
		baseUrl:
			options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
	} as QueryKey<TOptions>[0];
	if (infinite) {
		params._infinite = infinite;
	}
	if (tags) {
		params.tags = tags;
	}
	if (options?.body) {
		params.body = options.body;
	}
	if (options?.headers) {
		params.headers = options.headers;
	}
	if (options?.path) {
		params.path = options.path;
	}
	if (options?.query) {
		params.query = options.query;
	}
	return [params];
};

export const healthHealthCheckQueryKey = (
	options?: Options<HealthHealthCheckData>,
) => createQueryKey("healthHealthCheck", options);

/**
 * Health Check
 * Get comprehensive health status.
 */
export const healthHealthCheckOptions = (
	options?: Options<HealthHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.healthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthHealthCheckQueryKey(options),
	});
};

export const healthLivenessProbeQueryKey = (
	options?: Options<HealthLivenessProbeData>,
) => createQueryKey("healthLivenessProbe", options);

/**
 * Liveness Probe
 * Kubernetes liveness probe endpoint.
 */
export const healthLivenessProbeOptions = (
	options?: Options<HealthLivenessProbeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.livenessProbe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthLivenessProbeQueryKey(options),
	});
};

export const healthReadinessProbeQueryKey = (
	options?: Options<HealthReadinessProbeData>,
) => createQueryKey("healthReadinessProbe", options);

/**
 * Readiness Probe
 * Kubernetes readiness probe endpoint.
 */
export const healthReadinessProbeOptions = (
	options?: Options<HealthReadinessProbeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await HealthService.readinessProbe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: healthReadinessProbeQueryKey(options),
	});
};

/**
 * Login
 */
export const authLoginMutation = (
	options?: Partial<Options<AuthLoginData>>,
): UseMutationOptions<
	AuthLoginResponse,
	AuthLoginError,
	Options<AuthLoginData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthLoginResponse,
		AuthLoginError,
		Options<AuthLoginData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.login({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Logout
 * 로그아웃 엔드포인트.
 *
 * 쿠키에서 토큰을 삭제하고 로그아웃 처리를 합니다.
 */
export const authLogoutMutation = (
	options?: Partial<Options<AuthLogoutData>>,
): UseMutationOptions<
	AuthLogoutResponse,
	AuthLogoutError,
	Options<AuthLogoutData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthLogoutResponse,
		AuthLogoutError,
		Options<AuthLogoutData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.logout({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Refresh Token
 * JWT 토큰 갱신 엔드포인트
 */
export const authRefreshTokenMutation = (
	options?: Partial<Options<AuthRefreshTokenData>>,
): UseMutationOptions<
	AuthRefreshTokenResponse,
	AuthRefreshTokenError,
	Options<AuthRefreshTokenData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthRefreshTokenResponse,
		AuthRefreshTokenError,
		Options<AuthRefreshTokenData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.refreshToken({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const authVerifyTokenQueryKey = (
	options?: Options<AuthVerifyTokenData>,
) => createQueryKey("authVerifyToken", options);

/**
 * Verify Token
 * 토큰 검증 및 사용자 정보 반환 (디버깅용)
 */
export const authVerifyTokenOptions = (
	options?: Options<AuthVerifyTokenData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await AuthService.verifyToken({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: authVerifyTokenQueryKey(options),
	});
};

/**
 * Register
 */
export const authRegisterMutation = (
	options?: Partial<Options<AuthRegisterData>>,
): UseMutationOptions<
	AuthRegisterResponse,
	AuthRegisterError,
	Options<AuthRegisterData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthRegisterResponse,
		AuthRegisterError,
		Options<AuthRegisterData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.register({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Forgot Password
 */
export const authForgotPasswordMutation = (
	options?: Partial<Options<AuthForgotPasswordData>>,
): UseMutationOptions<
	unknown,
	AuthForgotPasswordError,
	Options<AuthForgotPasswordData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthForgotPasswordError,
		Options<AuthForgotPasswordData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.forgotPassword({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Reset Password
 */
export const authResetPasswordMutation = (
	options?: Partial<Options<AuthResetPasswordData>>,
): UseMutationOptions<
	unknown,
	AuthResetPasswordError,
	Options<AuthResetPasswordData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthResetPasswordError,
		Options<AuthResetPasswordData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.resetPassword({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Request Verify Token
 */
export const authRequestVerifyTokenMutation = (
	options?: Partial<Options<AuthRequestVerifyTokenData>>,
): UseMutationOptions<
	unknown,
	AuthRequestVerifyTokenError,
	Options<AuthRequestVerifyTokenData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		AuthRequestVerifyTokenError,
		Options<AuthRequestVerifyTokenData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.requestVerifyToken({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Verify
 */
export const authVerifyMutation = (
	options?: Partial<Options<AuthVerifyData>>,
): UseMutationOptions<
	AuthVerifyResponse,
	AuthVerifyError,
	Options<AuthVerifyData>
> => {
	const mutationOptions: UseMutationOptions<
		AuthVerifyResponse,
		AuthVerifyError,
		Options<AuthVerifyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await AuthService.verify({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserMeQueryKey = (options?: Options<UserGetUserMeData>) =>
	createQueryKey("userGetUserMe", options);

/**
 * Get User Me
 */
export const userGetUserMeOptions = (options?: Options<UserGetUserMeData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getUserMe({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserMeQueryKey(options),
	});
};

/**
 * Update User Me
 */
export const userUpdateUserMeMutation = (
	options?: Partial<Options<UserUpdateUserMeData>>,
): UseMutationOptions<
	UserUpdateUserMeResponse,
	UserUpdateUserMeError,
	Options<UserUpdateUserMeData>
> => {
	const mutationOptions: UseMutationOptions<
		UserUpdateUserMeResponse,
		UserUpdateUserMeError,
		Options<UserUpdateUserMeData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.updateUserMe({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete User
 */
export const userDeleteUserMutation = (
	options?: Partial<Options<UserDeleteUserData>>,
): UseMutationOptions<
	UserDeleteUserResponse,
	UserDeleteUserError,
	Options<UserDeleteUserData>
> => {
	const mutationOptions: UseMutationOptions<
		UserDeleteUserResponse,
		UserDeleteUserError,
		Options<UserDeleteUserData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.deleteUser({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserQueryKey = (options: Options<UserGetUserData>) =>
	createQueryKey("userGetUser", options);

/**
 * Get User
 */
export const userGetUserOptions = (options: Options<UserGetUserData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getUser({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserQueryKey(options),
	});
};

/**
 * Update User
 */
export const userUpdateUserMutation = (
	options?: Partial<Options<UserUpdateUserData>>,
): UseMutationOptions<
	UserUpdateUserResponse,
	UserUpdateUserError,
	Options<UserUpdateUserData>
> => {
	const mutationOptions: UseMutationOptions<
		UserUpdateUserResponse,
		UserUpdateUserError,
		Options<UserUpdateUserData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.updateUser({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const oAuth2AuthorizeQueryKey = (
	options: Options<OAuth2AuthorizeData>,
) => createQueryKey("oAuth2Authorize", options);

/**
 * Authorize
 * Initiate the OAuth2 authorization process for associating an OAuth account
 * with the currently authenticated user.
 */
export const oAuth2AuthorizeOptions = (
	options: Options<OAuth2AuthorizeData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await OAuth2Service.authorize({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: oAuth2AuthorizeQueryKey(options),
	});
};

export const oAuth2CallbackQueryKey = (options: Options<OAuth2CallbackData>) =>
	createQueryKey("oAuth2Callback", options);

/**
 * Callback
 * The response varies based on the authentication backend used.
 */
export const oAuth2CallbackOptions = (options: Options<OAuth2CallbackData>) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await OAuth2Service.callback({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: oAuth2CallbackQueryKey(options),
	});
};

export const userGetMyOauthAccountsQueryKey = (
	options?: Options<UserGetMyOauthAccountsData>,
) => createQueryKey("userGetMyOauthAccounts", options);

/**
 * Get My Oauth Accounts
 * 현재 사용자의 연결된 OAuth 계정 목록을 조회합니다.
 */
export const userGetMyOauthAccountsOptions = (
	options?: Options<UserGetMyOauthAccountsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getMyOauthAccounts({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetMyOauthAccountsQueryKey(options),
	});
};

/**
 * Remove Oauth Account
 * 특정 OAuth 계정 연결을 해제합니다.
 */
export const userRemoveOauthAccountMutation = (
	options?: Partial<Options<UserRemoveOauthAccountData>>,
): UseMutationOptions<
	UserRemoveOauthAccountResponse,
	UserRemoveOauthAccountError,
	Options<UserRemoveOauthAccountData>
> => {
	const mutationOptions: UseMutationOptions<
		UserRemoveOauthAccountResponse,
		UserRemoveOauthAccountError,
		Options<UserRemoveOauthAccountData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await UserService.removeOauthAccount({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const userGetUserOauthAccountsQueryKey = (
	options: Options<UserGetUserOauthAccountsData>,
) => createQueryKey("userGetUserOauthAccounts", options);

/**
 * Get User Oauth Accounts
 * 특정 사용자의 OAuth 계정 목록을 조회합니다. (관리자 전용)
 */
export const userGetUserOauthAccountsOptions = (
	options: Options<UserGetUserOauthAccountsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await UserService.getUserOauthAccounts({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: userGetUserOauthAccountsQueryKey(options),
	});
};

export const marketDataGetDailyPricesQueryKey = (
	options: Options<MarketDataGetDailyPricesData>,
) => createQueryKey("marketDataGetDailyPrices", options);

/**
 * Get Daily Prices
 * 지정된 종목의 일일 주가 데이터(OHLCV)를 조회합니다.
 */
export const marketDataGetDailyPricesOptions = (
	options: Options<MarketDataGetDailyPricesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getDailyPrices({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetDailyPricesQueryKey(options),
	});
};

export const marketDataGetQuoteQueryKey = (
	options: Options<MarketDataGetQuoteData>,
) => createQueryKey("marketDataGetQuote", options);

/**
 * Get Quote
 * 지정된 종목의 실시간 호가 정보를 조회합니다.
 */
export const marketDataGetQuoteOptions = (
	options: Options<MarketDataGetQuoteData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getQuote({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetQuoteQueryKey(options),
	});
};

export const marketDataGetIntradayDataQueryKey = (
	options: Options<MarketDataGetIntradayDataData>,
) => createQueryKey("marketDataGetIntradayData", options);

/**
 * Get Intraday Data
 * 지정된 종목의 실시간 또는 분봉 데이터를 조회합니다.
 */
export const marketDataGetIntradayDataOptions = (
	options: Options<MarketDataGetIntradayDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getIntradayData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetIntradayDataQueryKey(options),
	});
};

export const marketDataGetHistoricalDataQueryKey = (
	options: Options<MarketDataGetHistoricalDataData>,
) => createQueryKey("marketDataGetHistoricalData", options);

/**
 * Get Historical Data
 * 지정된 종목의 장기 히스토리 데이터를 조회합니다.
 */
export const marketDataGetHistoricalDataOptions = (
	options: Options<MarketDataGetHistoricalDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getHistoricalData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetHistoricalDataQueryKey(options),
	});
};

export const marketDataGetCompanyOverviewQueryKey = (
	options: Options<MarketDataGetCompanyOverviewData>,
) => createQueryKey("marketDataGetCompanyOverview", options);

/**
 * Get Company Overview
 * 지정된 종목의 기업 개요 정보를 조회합니다.
 */
export const marketDataGetCompanyOverviewOptions = (
	options: Options<MarketDataGetCompanyOverviewData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getCompanyOverview({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetCompanyOverviewQueryKey(options),
	});
};

export const marketDataGetIncomeStatementQueryKey = (
	options: Options<MarketDataGetIncomeStatementData>,
) => createQueryKey("marketDataGetIncomeStatement", options);

/**
 * Get Income Statement
 * 지정된 종목의 손익계산서를 조회합니다.
 */
export const marketDataGetIncomeStatementOptions = (
	options: Options<MarketDataGetIncomeStatementData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getIncomeStatement({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetIncomeStatementQueryKey(options),
	});
};

export const marketDataGetBalanceSheetQueryKey = (
	options: Options<MarketDataGetBalanceSheetData>,
) => createQueryKey("marketDataGetBalanceSheet", options);

/**
 * Get Balance Sheet
 * 지정된 종목의 재무상태표를 조회합니다.
 */
export const marketDataGetBalanceSheetOptions = (
	options: Options<MarketDataGetBalanceSheetData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getBalanceSheet({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetBalanceSheetQueryKey(options),
	});
};

export const marketDataGetCashFlowQueryKey = (
	options: Options<MarketDataGetCashFlowData>,
) => createQueryKey("marketDataGetCashFlow", options);

/**
 * Get Cash Flow
 * 지정된 종목의 현금흐름표를 조회합니다.
 */
export const marketDataGetCashFlowOptions = (
	options: Options<MarketDataGetCashFlowData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getCashFlow({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetCashFlowQueryKey(options),
	});
};

export const marketDataGetEarningsQueryKey = (
	options: Options<MarketDataGetEarningsData>,
) => createQueryKey("marketDataGetEarnings", options);

/**
 * Get Earnings
 * 지정된 종목의 실적 데이터를 조회합니다.
 */
export const marketDataGetEarningsOptions = (
	options: Options<MarketDataGetEarningsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getEarnings({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetEarningsQueryKey(options),
	});
};

export const marketDataGetGdpDataQueryKey = (
	options?: Options<MarketDataGetGdpDataData>,
) => createQueryKey("marketDataGetGdpData", options);

/**
 * Get Gdp Data
 * 미국 GDP 데이터를 조회합니다.
 */
export const marketDataGetGdpDataOptions = (
	options?: Options<MarketDataGetGdpDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getGdpData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetGdpDataQueryKey(options),
	});
};

export const marketDataGetInflationDataQueryKey = (
	options?: Options<MarketDataGetInflationDataData>,
) => createQueryKey("marketDataGetInflationData", options);

/**
 * Get Inflation Data
 * 미국 인플레이션 지표 데이터를 조회합니다.
 */
export const marketDataGetInflationDataOptions = (
	options?: Options<MarketDataGetInflationDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getInflationData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetInflationDataQueryKey(options),
	});
};

export const marketDataGetInterestRatesQueryKey = (
	options?: Options<MarketDataGetInterestRatesData>,
) => createQueryKey("marketDataGetInterestRates", options);

/**
 * Get Interest Rates
 * 미국 기준금리 및 채권 수익률 데이터를 조회합니다.
 */
export const marketDataGetInterestRatesOptions = (
	options?: Options<MarketDataGetInterestRatesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getInterestRates({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetInterestRatesQueryKey(options),
	});
};

export const marketDataGetEmploymentDataQueryKey = (
	options?: Options<MarketDataGetEmploymentDataData>,
) => createQueryKey("marketDataGetEmploymentData", options);

/**
 * Get Employment Data
 * 미국 실업률 및 고용 관련 지표를 조회합니다.
 */
export const marketDataGetEmploymentDataOptions = (
	options?: Options<MarketDataGetEmploymentDataData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getEmploymentData({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetEmploymentDataQueryKey(options),
	});
};

export const marketDataGetConsumerSentimentQueryKey = (
	options?: Options<MarketDataGetConsumerSentimentData>,
) => createQueryKey("marketDataGetConsumerSentiment", options);

/**
 * Get Consumer Sentiment
 * 미국 소비자 심리 지수를 조회합니다.
 */
export const marketDataGetConsumerSentimentOptions = (
	options?: Options<MarketDataGetConsumerSentimentData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getConsumerSentiment({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetConsumerSentimentQueryKey(options),
	});
};

export const marketDataGetNewsQueryKey = (
	options: Options<MarketDataGetNewsData>,
) => createQueryKey("marketDataGetNews", options);

/**
 * Get News
 * 지정된 종목 관련 뉴스를 조회합니다.
 */
export const marketDataGetNewsOptions = (
	options: Options<MarketDataGetNewsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getNews({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetNewsQueryKey(options),
	});
};

export const marketDataGetSentimentAnalysisQueryKey = (
	options: Options<MarketDataGetSentimentAnalysisData>,
) => createQueryKey("marketDataGetSentimentAnalysis", options);

/**
 * Get Sentiment Analysis
 * 지정된 종목의 감정 분석 결과를 조회합니다.
 */
export const marketDataGetSentimentAnalysisOptions = (
	options: Options<MarketDataGetSentimentAnalysisData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getSentimentAnalysis({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetSentimentAnalysisQueryKey(options),
	});
};

export const marketDataGetAnalystRecommendationsQueryKey = (
	options: Options<MarketDataGetAnalystRecommendationsData>,
) => createQueryKey("marketDataGetAnalystRecommendations", options);

/**
 * Get Analyst Recommendations
 * 지정된 종목의 분석가 추천 정보를 조회합니다.
 */
export const marketDataGetAnalystRecommendationsOptions = (
	options: Options<MarketDataGetAnalystRecommendationsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getAnalystRecommendations({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetAnalystRecommendationsQueryKey(options),
	});
};

export const marketDataGetSocialSentimentQueryKey = (
	options: Options<MarketDataGetSocialSentimentData>,
) => createQueryKey("marketDataGetSocialSentiment", options);

/**
 * Get Social Sentiment
 * 지정된 종목의 소셜 미디어 감정 분석을 조회합니다.
 */
export const marketDataGetSocialSentimentOptions = (
	options: Options<MarketDataGetSocialSentimentData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getSocialSentiment({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetSocialSentimentQueryKey(options),
	});
};

/**
 * Collect Company Info
 * 지정된 심볼의 기업 정보를 수집하여 저장
 *
 * Alpha Vantage API를 통해 기업의 기본 정보, 재무 지표,
 * 업종 분류 등을 수집하고 데이터베이스에 저장합니다.
 */
export const marketDataCollectCompanyInfoMutation = (
	options?: Partial<Options<MarketDataCollectCompanyInfoData>>,
): UseMutationOptions<
	unknown,
	MarketDataCollectCompanyInfoError,
	Options<MarketDataCollectCompanyInfoData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		MarketDataCollectCompanyInfoError,
		Options<MarketDataCollectCompanyInfoData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await MarketDataService.collectCompanyInfo({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Collect Market Data
 * 지정된 심볼의 주가 데이터를 수집하여 저장
 *
 * Alpha Vantage API를 통해 일일 OHLCV 데이터를 수집하고
 * DuckDB 캐시 및 MongoDB에 저장합니다.
 */
export const marketDataCollectMarketDataMutation = (
	options?: Partial<Options<MarketDataCollectMarketDataData>>,
): UseMutationOptions<
	unknown,
	MarketDataCollectMarketDataError,
	Options<MarketDataCollectMarketDataData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		MarketDataCollectMarketDataError,
		Options<MarketDataCollectMarketDataData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await MarketDataService.collectMarketData({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Collect Bulk Data
 * 여러 심볼의 데이터를 일괄 수집
 *
 * 백그라운드 작업으로 처리되며, 대량의 심볼에 대해
 * 기업 정보와 주가 데이터를 순차적으로 수집합니다.
 */
export const marketDataCollectBulkDataMutation = (
	options?: Partial<Options<MarketDataCollectBulkDataData>>,
): UseMutationOptions<
	unknown,
	MarketDataCollectBulkDataError,
	Options<MarketDataCollectBulkDataData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		MarketDataCollectBulkDataError,
		Options<MarketDataCollectBulkDataData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await MarketDataService.collectBulkData({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const marketDataGetDataCoverageQueryKey = (
	options: Options<MarketDataGetDataCoverageData>,
) => createQueryKey("marketDataGetDataCoverage", options);

/**
 * Get Data Coverage
 * 지정된 심볼의 데이터 커버리지 정보 조회
 *
 * 기업 정보, 주가 데이터의 수집 상태와 품질을 확인합니다.
 */
export const marketDataGetDataCoverageOptions = (
	options: Options<MarketDataGetDataCoverageData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getDataCoverage({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetDataCoverageQueryKey(options),
	});
};

export const marketDataGetSystemStatusQueryKey = (
	options?: Options<MarketDataGetSystemStatusData>,
) => createQueryKey("marketDataGetSystemStatus", options);

/**
 * Get System Status
 * 시장 데이터 시스템의 전반적인 상태 조회
 *
 * API 연결 상태, 캐시 성능, 수집 통계 등을 확인합니다.
 */
export const marketDataGetSystemStatusOptions = (
	options?: Options<MarketDataGetSystemStatusData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getSystemStatus({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetSystemStatusQueryKey(options),
	});
};

export const marketDataGetMarketDataInfoQueryKey = (
	options?: Options<MarketDataGetMarketDataInfoData>,
) => createQueryKey("marketDataGetMarketDataInfo", options);

/**
 * Get Market Data Info
 * 마켓 데이터 API 정보 및 사용 가능한 엔드포인트 목록
 */
export const marketDataGetMarketDataInfoOptions = (
	options?: Options<MarketDataGetMarketDataInfoData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.getMarketDataInfo({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataGetMarketDataInfoQueryKey(options),
	});
};

export const marketDataHealthCheckQueryKey = (
	options?: Options<MarketDataHealthCheckData>,
) => createQueryKey("marketDataHealthCheck", options);

/**
 * Health Check
 * 마켓 데이터 서비스 상태 확인
 */
export const marketDataHealthCheckOptions = (
	options?: Options<MarketDataHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await MarketDataService.healthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: marketDataHealthCheckQueryKey(options),
	});
};

export const strategyGetStrategiesQueryKey = (
	options?: Options<StrategyGetStrategiesData>,
) => createQueryKey("strategyGetStrategies", options);

/**
 * Get Strategies
 * Get list of strategies
 */
export const strategyGetStrategiesOptions = (
	options?: Options<StrategyGetStrategiesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategies({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategiesQueryKey(options),
	});
};

/**
 * Create Strategy
 * Create a new strategy
 */
export const strategyCreateStrategyMutation = (
	options?: Partial<Options<StrategyCreateStrategyData>>,
): UseMutationOptions<
	StrategyCreateStrategyResponse,
	StrategyCreateStrategyError,
	Options<StrategyCreateStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateStrategyResponse,
		StrategyCreateStrategyError,
		Options<StrategyCreateStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.createStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Strategy
 * Delete strategy (soft delete)
 */
export const strategyDeleteStrategyMutation = (
	options?: Partial<Options<StrategyDeleteStrategyData>>,
): UseMutationOptions<
	unknown,
	StrategyDeleteStrategyError,
	Options<StrategyDeleteStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		StrategyDeleteStrategyError,
		Options<StrategyDeleteStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.deleteStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetStrategyQueryKey = (
	options: Options<StrategyGetStrategyData>,
) => createQueryKey("strategyGetStrategy", options);

/**
 * Get Strategy
 * Get strategy by ID
 */
export const strategyGetStrategyOptions = (
	options: Options<StrategyGetStrategyData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategy({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyQueryKey(options),
	});
};

/**
 * Update Strategy
 * Update strategy
 */
export const strategyUpdateStrategyMutation = (
	options?: Partial<Options<StrategyUpdateStrategyData>>,
): UseMutationOptions<
	StrategyUpdateStrategyResponse,
	StrategyUpdateStrategyError,
	Options<StrategyUpdateStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyUpdateStrategyResponse,
		StrategyUpdateStrategyError,
		Options<StrategyUpdateStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.updateStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Execute Strategy
 * Execute strategy and generate signal
 */
export const strategyExecuteStrategyMutation = (
	options?: Partial<Options<StrategyExecuteStrategyData>>,
): UseMutationOptions<
	StrategyExecuteStrategyResponse,
	StrategyExecuteStrategyError,
	Options<StrategyExecuteStrategyData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyExecuteStrategyResponse,
		StrategyExecuteStrategyError,
		Options<StrategyExecuteStrategyData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.executeStrategy({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetStrategyExecutionsQueryKey = (
	options: Options<StrategyGetStrategyExecutionsData>,
) => createQueryKey("strategyGetStrategyExecutions", options);

/**
 * Get Strategy Executions
 * Get strategy execution history
 */
export const strategyGetStrategyExecutionsOptions = (
	options: Options<StrategyGetStrategyExecutionsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategyExecutions({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyExecutionsQueryKey(options),
	});
};

export const strategyGetStrategyPerformanceQueryKey = (
	options: Options<StrategyGetStrategyPerformanceData>,
) => createQueryKey("strategyGetStrategyPerformance", options);

/**
 * Get Strategy Performance
 * Get strategy performance metrics
 */
export const strategyGetStrategyPerformanceOptions = (
	options: Options<StrategyGetStrategyPerformanceData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getStrategyPerformance({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetStrategyPerformanceQueryKey(options),
	});
};

export const strategyGetTemplatesQueryKey = (
	options?: Options<StrategyGetTemplatesData>,
) => createQueryKey("strategyGetTemplates", options);

/**
 * Get Templates
 * Get list of strategy templates
 */
export const strategyGetTemplatesOptions = (
	options?: Options<StrategyGetTemplatesData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getTemplates({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplatesQueryKey(options),
	});
};

/**
 * Create Template
 * Create a new strategy template (Superuser only)
 */
export const strategyCreateTemplateMutation = (
	options?: Partial<Options<StrategyCreateTemplateData>>,
): UseMutationOptions<
	StrategyCreateTemplateResponse,
	StrategyCreateTemplateError,
	Options<StrategyCreateTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateTemplateResponse,
		StrategyCreateTemplateError,
		Options<StrategyCreateTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.createTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Template
 * Delete template by ID (Superuser only)
 */
export const strategyDeleteTemplateMutation = (
	options?: Partial<Options<StrategyDeleteTemplateData>>,
): UseMutationOptions<
	unknown,
	StrategyDeleteTemplateError,
	Options<StrategyDeleteTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		StrategyDeleteTemplateError,
		Options<StrategyDeleteTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.deleteTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetTemplateQueryKey = (
	options: Options<StrategyGetTemplateData>,
) => createQueryKey("strategyGetTemplate", options);

/**
 * Get Template
 * Get template by ID
 */
export const strategyGetTemplateOptions = (
	options: Options<StrategyGetTemplateData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getTemplate({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplateQueryKey(options),
	});
};

/**
 * Update Template
 * Update template by ID (Superuser only)
 */
export const strategyUpdateTemplateMutation = (
	options?: Partial<Options<StrategyUpdateTemplateData>>,
): UseMutationOptions<
	StrategyUpdateTemplateResponse,
	StrategyUpdateTemplateError,
	Options<StrategyUpdateTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyUpdateTemplateResponse,
		StrategyUpdateTemplateError,
		Options<StrategyUpdateTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.updateTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Create Strategy From Template
 * Create a strategy instance from template
 */
export const strategyCreateStrategyFromTemplateMutation = (
	options?: Partial<Options<StrategyCreateStrategyFromTemplateData>>,
): UseMutationOptions<
	StrategyCreateStrategyFromTemplateResponse,
	StrategyCreateStrategyFromTemplateError,
	Options<StrategyCreateStrategyFromTemplateData>
> => {
	const mutationOptions: UseMutationOptions<
		StrategyCreateStrategyFromTemplateResponse,
		StrategyCreateStrategyFromTemplateError,
		Options<StrategyCreateStrategyFromTemplateData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await StrategyService.createStrategyFromTemplate({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const strategyGetTemplateUsageStatsQueryKey = (
	options?: Options<StrategyGetTemplateUsageStatsData>,
) => createQueryKey("strategyGetTemplateUsageStats", options);

/**
 * Get Template Usage Stats
 * Get template usage statistics
 */
export const strategyGetTemplateUsageStatsOptions = (
	options?: Options<StrategyGetTemplateUsageStatsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await StrategyService.getTemplateUsageStats({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: strategyGetTemplateUsageStatsQueryKey(options),
	});
};

export const backtestsGetBacktestsQueryKey = (
	options?: Options<BacktestsGetBacktestsData>,
) => createQueryKey("backtestsGetBacktests", options);

/**
 * Get Backtests
 * Get list of backtests
 */
export const backtestsGetBacktestsOptions = (
	options?: Options<BacktestsGetBacktestsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktests({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestsQueryKey(options),
	});
};

/**
 * Create Backtest
 * Create a new backtest
 */
export const backtestsCreateBacktestMutation = (
	options?: Partial<Options<BacktestsCreateBacktestData>>,
): UseMutationOptions<
	BacktestsCreateBacktestResponse,
	BacktestsCreateBacktestError,
	Options<BacktestsCreateBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsCreateBacktestResponse,
		BacktestsCreateBacktestError,
		Options<BacktestsCreateBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.createBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Backtest
 * Delete backtest
 */
export const backtestsDeleteBacktestMutation = (
	options?: Partial<Options<BacktestsDeleteBacktestData>>,
): UseMutationOptions<
	unknown,
	BacktestsDeleteBacktestError,
	Options<BacktestsDeleteBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		BacktestsDeleteBacktestError,
		Options<BacktestsDeleteBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.deleteBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsGetBacktestQueryKey = (
	options: Options<BacktestsGetBacktestData>,
) => createQueryKey("backtestsGetBacktest", options);

/**
 * Get Backtest
 * Get backtest by ID
 */
export const backtestsGetBacktestOptions = (
	options: Options<BacktestsGetBacktestData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktest({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestQueryKey(options),
	});
};

/**
 * Update Backtest
 * Update backtest
 */
export const backtestsUpdateBacktestMutation = (
	options?: Partial<Options<BacktestsUpdateBacktestData>>,
): UseMutationOptions<
	BacktestsUpdateBacktestResponse,
	BacktestsUpdateBacktestError,
	Options<BacktestsUpdateBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsUpdateBacktestResponse,
		BacktestsUpdateBacktestError,
		Options<BacktestsUpdateBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.updateBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Execute Backtest
 * Execute backtest with trading signals
 */
export const backtestsExecuteBacktestMutation = (
	options?: Partial<Options<BacktestsExecuteBacktestData>>,
): UseMutationOptions<
	BacktestsExecuteBacktestResponse,
	BacktestsExecuteBacktestError,
	Options<BacktestsExecuteBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsExecuteBacktestResponse,
		BacktestsExecuteBacktestError,
		Options<BacktestsExecuteBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.executeBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsGetBacktestExecutionsQueryKey = (
	options: Options<BacktestsGetBacktestExecutionsData>,
) => createQueryKey("backtestsGetBacktestExecutions", options);

/**
 * Get Backtest Executions
 * Get execution history for a backtest
 */
export const backtestsGetBacktestExecutionsOptions = (
	options: Options<BacktestsGetBacktestExecutionsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktestExecutions({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestExecutionsQueryKey(options),
	});
};

export const backtestsGetBacktestResultsQueryKey = (
	options?: Options<BacktestsGetBacktestResultsData>,
) => createQueryKey("backtestsGetBacktestResults", options);

/**
 * Get Backtest Results
 * Get backtest results from DuckDB (고성능 분석용)
 */
export const backtestsGetBacktestResultsOptions = (
	options?: Options<BacktestsGetBacktestResultsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktestResults({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestResultsQueryKey(options),
	});
};

/**
 * Create And Run Integrated Backtest
 * 통합 백테스트 생성 및 실행 - 모든 서비스 연동
 */
export const backtestsCreateAndRunIntegratedBacktestMutation = (
	options?: Partial<Options<BacktestsCreateAndRunIntegratedBacktestData>>,
): UseMutationOptions<
	BacktestsCreateAndRunIntegratedBacktestResponse,
	BacktestsCreateAndRunIntegratedBacktestError,
	Options<BacktestsCreateAndRunIntegratedBacktestData>
> => {
	const mutationOptions: UseMutationOptions<
		BacktestsCreateAndRunIntegratedBacktestResponse,
		BacktestsCreateAndRunIntegratedBacktestError,
		Options<BacktestsCreateAndRunIntegratedBacktestData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await BacktestsService.createAndRunIntegratedBacktest({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const backtestsHealthCheckQueryKey = (
	options?: Options<BacktestsHealthCheckData>,
) => createQueryKey("backtestsHealthCheck", options);

/**
 * Health Check
 * 백테스트 시스템 상태 확인 (DuckDB + MongoDB 통합 상태)
 */
export const backtestsHealthCheckOptions = (
	options?: Options<BacktestsHealthCheckData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.healthCheck({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsHealthCheckQueryKey(options),
	});
};

export const backtestsGetPerformanceAnalyticsQueryKey = (
	options?: Options<BacktestsGetPerformanceAnalyticsData>,
) => createQueryKey("backtestsGetPerformanceAnalytics", options);

/**
 * Get Performance Analytics
 * 백테스트 성과 분석 (DuckDB 고성능 분석)
 */
export const backtestsGetPerformanceAnalyticsOptions = (
	options?: Options<BacktestsGetPerformanceAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getPerformanceAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetPerformanceAnalyticsQueryKey(options),
	});
};

export const backtestsGetTradesAnalyticsQueryKey = (
	options?: Options<BacktestsGetTradesAnalyticsData>,
) => createQueryKey("backtestsGetTradesAnalytics", options);

/**
 * Get Trades Analytics
 * 거래 기록 분석 (DuckDB 고성능 쿼리)
 */
export const backtestsGetTradesAnalyticsOptions = (
	options?: Options<BacktestsGetTradesAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getTradesAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetTradesAnalyticsQueryKey(options),
	});
};

export const backtestsGetBacktestSummaryAnalyticsQueryKey = (
	options?: Options<BacktestsGetBacktestSummaryAnalyticsData>,
) => createQueryKey("backtestsGetBacktestSummaryAnalytics", options);

/**
 * Get Backtest Summary Analytics
 * 백테스트 결과 요약 분석 (DuckDB 기반)
 */
export const backtestsGetBacktestSummaryAnalyticsOptions = (
	options?: Options<BacktestsGetBacktestSummaryAnalyticsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await BacktestsService.getBacktestSummaryAnalytics({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: backtestsGetBacktestSummaryAnalyticsQueryKey(options),
	});
};

export const watchlistsListWatchlistsQueryKey = (
	options?: Options<WatchlistsListWatchlistsData>,
) => createQueryKey("watchlistsListWatchlists", options);

/**
 * List Watchlists
 * 사용자의 모든 워치리스트 목록 조회
 *
 * 사용자에게 속한 모든 워치리스트의 요약 정보를 반환합니다.
 */
export const watchlistsListWatchlistsOptions = (
	options?: Options<WatchlistsListWatchlistsData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await WatchlistsService.listWatchlists({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: watchlistsListWatchlistsQueryKey(options),
	});
};

/**
 * Create Or Update Watchlist
 * 워치리스트 생성 또는 업데이트
 *
 * 유연한 워치리스트 관리를 위한 엔드포인트입니다.
 * - 이름이 없으면 'default' 워치리스트로 처리
 * - 기존 워치리스트가 있으면 업데이트, 없으면 생성
 * - 심볼 데이터는 백그라운드에서 자동 수집
 */
export const watchlistsCreateOrUpdateWatchlistMutation = (
	options?: Partial<Options<WatchlistsCreateOrUpdateWatchlistData>>,
): UseMutationOptions<
	unknown,
	WatchlistsCreateOrUpdateWatchlistError,
	Options<WatchlistsCreateOrUpdateWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		WatchlistsCreateOrUpdateWatchlistError,
		Options<WatchlistsCreateOrUpdateWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await WatchlistsService.createOrUpdateWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Create Watchlist
 * 새로운 명명된 워치리스트 생성
 *
 * 명시적인 이름을 가진 새 워치리스트를 생성합니다.
 * 동일한 이름의 워치리스트가 이미 있으면 실패합니다.
 */
export const watchlistsCreateWatchlistMutation = (
	options?: Partial<Options<WatchlistsCreateWatchlistData>>,
): UseMutationOptions<
	unknown,
	WatchlistsCreateWatchlistError,
	Options<WatchlistsCreateWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		WatchlistsCreateWatchlistError,
		Options<WatchlistsCreateWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await WatchlistsService.createWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

/**
 * Delete Watchlist
 * 워치리스트 삭제
 */
export const watchlistsDeleteWatchlistMutation = (
	options?: Partial<Options<WatchlistsDeleteWatchlistData>>,
): UseMutationOptions<
	unknown,
	WatchlistsDeleteWatchlistError,
	Options<WatchlistsDeleteWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		WatchlistsDeleteWatchlistError,
		Options<WatchlistsDeleteWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await WatchlistsService.deleteWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const watchlistsGetWatchlistQueryKey = (
	options: Options<WatchlistsGetWatchlistData>,
) => createQueryKey("watchlistsGetWatchlist", options);

/**
 * Get Watchlist
 * 특정 워치리스트의 상세 정보 조회
 */
export const watchlistsGetWatchlistOptions = (
	options: Options<WatchlistsGetWatchlistData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await WatchlistsService.getWatchlist({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: watchlistsGetWatchlistQueryKey(options),
	});
};

/**
 * Update Watchlist
 * 기존 워치리스트 업데이트
 */
export const watchlistsUpdateWatchlistMutation = (
	options?: Partial<Options<WatchlistsUpdateWatchlistData>>,
): UseMutationOptions<
	unknown,
	WatchlistsUpdateWatchlistError,
	Options<WatchlistsUpdateWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		WatchlistsUpdateWatchlistError,
		Options<WatchlistsUpdateWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await WatchlistsService.updateWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};

export const watchlistsGetWatchlistCoverageQueryKey = (
	options: Options<WatchlistsGetWatchlistCoverageData>,
) => createQueryKey("watchlistsGetWatchlistCoverage", options);

/**
 * Get Watchlist Coverage
 * 워치리스트의 데이터 커버리지 정보 조회
 *
 * 각 심볼별로 수집된 데이터의 상태와 품질을 확인합니다.
 */
export const watchlistsGetWatchlistCoverageOptions = (
	options: Options<WatchlistsGetWatchlistCoverageData>,
) => {
	return queryOptions({
		queryFn: async ({ queryKey, signal }) => {
			const { data } = await WatchlistsService.getWatchlistCoverage({
				...options,
				...queryKey[0],
				signal,
				throwOnError: true,
			});
			return data;
		},
		queryKey: watchlistsGetWatchlistCoverageQueryKey(options),
	});
};

/**
 * Setup Default Watchlist
 * 기본 워치리스트 설정
 *
 * 인기 주식들로 구성된 기본 워치리스트를 생성합니다.
 */
export const watchlistsSetupDefaultWatchlistMutation = (
	options?: Partial<Options<WatchlistsSetupDefaultWatchlistData>>,
): UseMutationOptions<
	unknown,
	WatchlistsSetupDefaultWatchlistError,
	Options<WatchlistsSetupDefaultWatchlistData>
> => {
	const mutationOptions: UseMutationOptions<
		unknown,
		WatchlistsSetupDefaultWatchlistError,
		Options<WatchlistsSetupDefaultWatchlistData>
	> = {
		mutationFn: async (fnOptions) => {
			const { data } = await WatchlistsService.setupDefaultWatchlist({
				...options,
				...fnOptions,
				throwOnError: true,
			});
			return data;
		},
	};
	return mutationOptions;
};
