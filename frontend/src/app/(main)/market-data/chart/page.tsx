"use client";

import { Box } from "@mui/material";
import { LocalizationProvider } from "@mui/x-date-pickers";
import { AdapterDayjs } from "@mui/x-date-pickers/AdapterDayjs";
import dayjs, { type Dayjs } from "dayjs";
import "dayjs/locale/ko";
import React from "react";
import LightWeightChart from '@/components/market-data/LightweightChart';

import ChartControls from "@/components/market-data/ChartControls";
import MarketDataHeader from "@/components/market-data/MarketDataHeader";
import {
  useStockDailyPrices,
  useStockIntraday,
  useStockMonthlyPrices,
  useStockQuote,
  useStockWeeklyPrices,
} from "@/hooks/useStocks";
import { useWatchlist } from "@/hooks/useWatchList";

// ÌïúÍµ≠Ïñ¥ Î°úÏºÄÏùº ÏÑ§Ï†ï
dayjs.locale("ko");

interface CandlestickData {
  time: string;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

export default function MarketDataChartPage() {
  const [selectedSymbol, setSelectedSymbol] = React.useState<string>("");
  const [startDate, setStartDate] = React.useState<Dayjs | null>(
    dayjs().subtract(1, "month")
  );
  const [endDate, setEndDate] = React.useState<Dayjs | null>(dayjs());
  const [interval, setInterval] = React.useState<string>("daily"); // Í∏∞Î≥∏Í∞í: ÏùºÎ¥â
  const [chartType, setChartType] = React.useState("candlestick");
  const [adjusted, setAdjusted] = React.useState(true); // Adjusted prices Í∏∞Î≥∏Í∞í

  // ÏõåÏπòÎ¶¨Ïä§Ìä∏ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
  const {
    watchlistList,
    isLoading: { watchlistList: watchlistLoading },
  } = useWatchlist();

  // API ÏùëÎãµ Íµ¨Ï°∞ Ï≤òÎ¶¨: { user_id, watchlists: [...] }
  const watchlists = React.useMemo(() => {
    if (!watchlistList) return [];

    if (Array.isArray(watchlistList)) {
      return watchlistList;
    }

    if (typeof watchlistList === "object" && "watchlists" in watchlistList) {
      return Array.isArray((watchlistList as any).watchlists)
        ? (watchlistList as any).watchlists
        : [];
    }

    return [];
  }, [watchlistList]);

  // Ï≤´ Î≤àÏß∏ ÏõåÏπòÎ¶¨Ïä§Ìä∏Ïùò Ï≤´ Î≤àÏß∏ Ïã¨Î≥ºÏùÑ Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏÑ§Ï†ï
  React.useEffect(() => {
    if (watchlists.length > 0 && !selectedSymbol) {
      const firstWatchlist = watchlists[0];
      const firstSymbol = firstWatchlist?.symbols?.[0];
      if (firstSymbol) {
        setSelectedSymbol(firstSymbol);
      }
    }
  }, [watchlists, selectedSymbol]);

  // Í∏∞Í∞ÑÏóê Îî∞Î•∏ Ï†ÅÏ†àÌïú API ÏÑ†ÌÉù
  const apiType = React.useMemo(() => {
    // interval Í∞íÏúºÎ°ú API Í≤∞Ï†ï
    // Î∂ÑÎ¥â: 1min, 5min, 15min, 30min, 60min
    if (["1min", "5min", "15min", "30min", "60min"].includes(interval)) {
      return "intraday";
    }
    // Ï£ºÎ¥â
    if (interval === "weekly") {
      return "weekly";
    }
    // ÏõîÎ¥â
    if (interval === "monthly") {
      return "monthly";
    }
    // ÏùºÎ¥â (Í∏∞Î≥∏Í∞í)
    return "daily";
  }, [interval]);

  // Ïã§ÏãúÍ∞Ñ Quote (Ìï≠ÏÉÅ ÌïÑÏöî)
  const { data: currentQuote, isLoading: quoteLoading } =
    useStockQuote(selectedSymbol);

  // Intraday API
  const { data: intradayData, isLoading: intradayLoading } = useStockIntraday(
    selectedSymbol,
    {
      interval: interval as "1min" | "5min" | "15min" | "30min" | "60min",
      enabled: apiType === "intraday" && !!selectedSymbol,
    }
  );

  // Daily API
  const { data: dailyPrices, isLoading: dailyLoading } = useStockDailyPrices(
    selectedSymbol,
    {
      outputsize: "full",
      adjusted,
      startDate: startDate?.format("YYYY-MM-DD"),
      endDate: endDate?.format("YYYY-MM-DD"),
      enabled: apiType === "daily" && !!selectedSymbol,
    }
  );

  // Weekly API
  const { data: weeklyPrices, isLoading: weeklyLoading } = useStockWeeklyPrices(
    selectedSymbol,
    {
      outputsize: "full",
      adjusted,
      startDate: startDate?.format("YYYY-MM-DD"),
      endDate: endDate?.format("YYYY-MM-DD"),
      enabled: apiType === "weekly" && !!selectedSymbol,
    }
  );

  // Monthly API
  const { data: monthlyPrices, isLoading: monthlyLoading } =
    useStockMonthlyPrices(selectedSymbol, {
      outputsize: "full",
      adjusted,
      startDate: startDate?.format("YYYY-MM-DD"),
      endDate: endDate?.format("YYYY-MM-DD"),
      enabled: apiType === "monthly" && !!selectedSymbol,
    });

  // ÎîîÎ≤ÑÍπÖ: API Ìò∏Ï∂ú Ï°∞Í±¥ ÌôïÏù∏
  React.useEffect(() => {
    console.log("üîç API Call Conditions:", {
      selectedSymbol,
      interval,
      apiType,
      startDate: startDate?.format("YYYY-MM-DD"),
      endDate: endDate?.format("YYYY-MM-DD"),
      enabledConditions: {
        intraday: apiType === "intraday" && !!selectedSymbol,
        daily: apiType === "daily" && !!selectedSymbol,
        weekly: apiType === "weekly" && !!selectedSymbol,
        monthly: apiType === "monthly" && !!selectedSymbol,
      },
    });
  }, [selectedSymbol, apiType, interval, startDate, endDate]);

  const handleSymbolChange = React.useCallback((symbol: string) => {
    setSelectedSymbol(symbol);
  }, []);

  // ÎîîÎ≤ÑÍπÖ: Îç∞Ïù¥ÌÑ∞ ÏÉÅÌÉú ÌôïÏù∏
  React.useEffect(() => {
    console.log("üìä Chart Data Debug:", {
      selectedSymbol,
      apiType,
      interval,
      intradayData: intradayData
        ? Array.isArray(intradayData)
          ? `Array[${intradayData.length}]`
          : "Object"
        : "null",
      dailyPrices: dailyPrices
        ? Array.isArray(dailyPrices)
          ? `Array[${dailyPrices.length}]`
          : "Object"
        : "null",
      weeklyPrices: weeklyPrices
        ? Array.isArray(weeklyPrices)
          ? `Array[${weeklyPrices.length}]`
          : "Object"
        : "null",
      monthlyPrices: monthlyPrices
        ? Array.isArray(monthlyPrices)
          ? `Array[${monthlyPrices.length}]`
          : "Object"
        : "null",
      isLoading: {
        intradayLoading,
        dailyLoading,
        weeklyLoading,
        monthlyLoading,
      },
    });
  }, [
    selectedSymbol,
    apiType,
    interval,
    intradayData,
    dailyPrices,
    weeklyPrices,
    monthlyPrices,
    intradayLoading,
    dailyLoading,
    weeklyLoading,
    monthlyLoading,
  ]);

  // Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Í≤∞Ï†ï - apiTypeÏóê Îî∞Îùº Ï†ÅÏ†àÌïú Îç∞Ïù¥ÌÑ∞ ÏÑ†ÌÉù
  const rawData = React.useMemo(() => {
    if (apiType === "intraday") return intradayData;
    if (apiType === "daily") return dailyPrices;
    if (apiType === "weekly") return weeklyPrices;
    if (apiType === "monthly") return monthlyPrices;
    return null;
  }, [apiType, intradayData, dailyPrices, weeklyPrices, monthlyPrices]);

  // ÎßàÏºì Îç∞Ïù¥ÌÑ∞Î•º Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞Î°ú Î≥ÄÌôò
  const chartData: CandlestickData[] = React.useMemo(() => {
    if (!rawData) {
      console.log("üìà No rawData");
      return [];
    }

    console.log("üìà Raw data structure:", rawData);

    // rawDataÍ∞Ä Î∞∞Ïó¥Ïù∏ÏßÄ ÌôïÏù∏
    let dataArray: any[] = [];

    if (Array.isArray(rawData)) {
      dataArray = rawData;
    } else if (typeof rawData === "object") {
      // Î∞±ÏóîÎìú ÏùëÎãµ Íµ¨Ï°∞: { symbol, data: [...], count, start_date, end_date, frequency }
      if ("data" in rawData && Array.isArray((rawData as any).data)) {
        dataArray = (rawData as any).data;
        console.log("üìà Extracted data array from response:", {
          symbol: (rawData as any).symbol,
          count: (rawData as any).count,
          dataLength: dataArray.length,
        });
      } else if (
        "prices" in rawData &&
        Array.isArray((rawData as any).prices)
      ) {
        dataArray = (rawData as any).prices;
      } else if (
        "time_series" in rawData &&
        Array.isArray((rawData as any).time_series)
      ) {
        dataArray = (rawData as any).time_series;
      } else {
        console.warn("‚ùå Unknown data structure:", rawData);
        return [];
      }
    }

    if (dataArray.length === 0) {
      console.log("‚ö†Ô∏è Data array is empty");
      return [];
    }

    console.log("üìà Processing chart data:", {
      dataArrayLength: dataArray.length,
      firstItem: dataArray[0],
      lastItem: dataArray[dataArray.length - 1],
    });

    const processed = dataArray
      .map((item) => {
        const dateStr = item.date || item.timestamp || item.time;

        // Ïù∏Ìä∏ÎùºÎç∞Ïù¥ Îç∞Ïù¥ÌÑ∞Ïù∏ Í≤ΩÏö∞ ÏãúÍ∞Ñ Ï†ïÎ≥¥Î•º Ìè¨Ìï®Ìïú ISO ÌòïÏãù Ïú†ÏßÄ
        // ÏùºÎ≥Ñ Îç∞Ïù¥ÌÑ∞Ïù∏ Í≤ΩÏö∞ ÎÇ†ÏßúÎßå Ï∂îÏ∂ú
        const hasTimeInfo = dateStr?.includes("T") || dateStr?.includes(":");
        const timeValue = hasTimeInfo
          ? dateStr // ISO 8601 ÌòïÏãù Ïú†ÏßÄ (2025-10-07T10:30:00)
          : dayjs(dateStr).format("YYYY-MM-DD"); // ÏùºÎ≥Ñ Îç∞Ïù¥ÌÑ∞ (2025-10-07)

        return {
          time: timeValue,
          open: Number(item.open) || 0,
          high: Number(item.high) || 0,
          low: Number(item.low) || 0,
          close: Number(item.close) || 0,
          volume: Number(item.volume) || 0,
        };
      })
      .filter(
        (item) =>
          item.open > 0 && item.high > 0 && item.low > 0 && item.close > 0
      )
      .sort((a, b) => {
        // ÏãúÍ∞Ñ Ï†ïÎ≥¥Í∞Ä ÏûàÎäî Í≤ΩÏö∞ ISO Î¨∏ÏûêÏó¥ ÎπÑÍµê, ÏóÜÎäî Í≤ΩÏö∞ ÎÇ†Ïßú Î¨∏ÏûêÏó¥ ÎπÑÍµê
        return a.time.localeCompare(b.time);
      });

    console.log("‚úÖ Processed chart data:", {
      count: processed.length,
      firstItem: processed[0],
      lastItem: processed[processed.length - 1],
    });

    return processed;
  }, [rawData]);

  // chartData Î≥ÄÍ≤Ω Í∞êÏßÄ
  React.useEffect(() => {
    console.log("üìä ChartData Changed:", {
      chartDataLength: chartData.length,
      hasData: chartData.length > 0,
      firstItem: chartData[0],
      lastItem: chartData[chartData.length - 1],
    });
  }, [chartData]);

  // ÏöîÏïΩ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (Ïã§ÏãúÍ∞Ñ Ìò∏Í∞Ä + Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìï©)
  const summaryData = React.useMemo(() => {
    if (!chartData.length && !currentQuote) return null;

    const latestChartData = chartData[chartData.length - 1];
    const previousChartData = chartData[chartData.length - 2];

    // Ïã§ÏãúÍ∞Ñ Ìò∏Í∞Ä Ï†ïÎ≥¥Í∞Ä ÏûàÏúºÎ©¥ Ïö∞ÏÑ† ÏÇ¨Ïö©
    if (currentQuote) {
      const currentPrice =
        Number((currentQuote as any)?.price) || latestChartData?.close || 0;
      const previousClose =
        Number((currentQuote as any)?.previous_close) ||
        previousChartData?.close ||
        0;
      const change = currentPrice - previousClose;
      const changePercent =
        previousClose > 0 ? (change / previousClose) * 100 : 0;

      return {
        symbol: selectedSymbol,
        currentPrice,
        change,
        changePercent,
        volume:
          Number((currentQuote as any)?.volume) || latestChartData?.volume || 0,
        high: Number((currentQuote as any)?.high) || latestChartData?.high || 0,
        low: Number((currentQuote as any)?.low) || latestChartData?.low || 0,
        open: Number((currentQuote as any)?.open) || latestChartData?.open || 0,
        previousClose,
        marketCap: (currentQuote as any)?.market_cap,
        peRatio: (currentQuote as any)?.pe_ratio,
      };
    } // Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞Îßå ÏûàÎäî Í≤ΩÏö∞
    if (latestChartData && previousChartData) {
      const change = latestChartData.close - previousChartData.close;
      const changePercent = (change / previousChartData.close) * 100;

      return {
        symbol: selectedSymbol,
        currentPrice: latestChartData.close,
        change,
        changePercent,
        volume: latestChartData.volume,
        high: latestChartData.high,
        low: latestChartData.low,
        open: latestChartData.open,
        previousClose: previousChartData.close,
      };
    }

    return null;
  }, [chartData, currentQuote, selectedSymbol]);

  const isLoading = React.useMemo(() => {
    let dataLoading = false;
    if (apiType === "intraday") dataLoading = intradayLoading;
    else if (apiType === "daily") dataLoading = dailyLoading;
    else if (apiType === "weekly") dataLoading = weeklyLoading;
    else if (apiType === "monthly") dataLoading = monthlyLoading;

    return watchlistLoading || quoteLoading || dataLoading;
  }, [
    watchlistLoading,
    quoteLoading,
    apiType,
    intradayLoading,
    dailyLoading,
    weeklyLoading,
    monthlyLoading,
  ]);

  return (
    <LocalizationProvider dateAdapter={AdapterDayjs} adapterLocale="ko">
      <Box sx={{ height: "100vh", display: "flex", flexDirection: "column" }}>
        {/* ÏÉÅÎã® Ìó§Îçî - Ïã¨Î≥º Ï†ïÎ≥¥ Î∞è Í∞ÄÍ≤© */}
        <MarketDataHeader data={summaryData} isLoading={isLoading} />

        {/* Î©îÏù∏ Ïª®ÌÖêÏ∏† ÏòÅÏó≠ */}
        <Box sx={{ flexGrow: 1, display: "flex" }}>
          {/* ÏôºÏ™Ω - Ï∞®Ìä∏ ÏòÅÏó≠ */}
          <Box sx={{ flexGrow: 1, display: "flex", flexDirection: "column" }}>
            {/* Ï∞®Ìä∏ */}
            <Box sx={{ flexGrow: 1, p: 2 }}>
              {!selectedSymbol ? (
                <Box
                  display="flex"
                  alignItems="center"
                  justifyContent="center"
                  height="100%"
                  sx={{
                    border: 1,
                    borderColor: "divider",
                    borderRadius: 1,
                    backgroundColor: "background.paper",
                  }}
                >
                  <Box textAlign="center">
                    ÏõåÏπòÎ¶¨Ïä§Ìä∏ÏóêÏÑú Ï¢ÖÎ™©ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî
                  </Box>
                </Box>
              ) : chartData.length > 0 ? (
                <LightWeightChart
                  data={chartData}
                  symbol={selectedSymbol}
                  height={
                    typeof window !== "undefined"
                      ? window.innerHeight - 300
                      : 600
                  }
                  showVolume={true}
                />
              ) : (
                <Box
                  display="flex"
                  alignItems="center"
                  justifyContent="center"
                  height="100%"
                  sx={{
                    border: 1,
                    borderColor: "divider",
                    borderRadius: 1,
                    backgroundColor: "background.paper",
                  }}
                >
                  <Box textAlign="center">
                    {isLoading
                      ? "Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞Î•º Î°úÎî© Ï§ëÏûÖÎãàÎã§..."
                      : "Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§"}
                  </Box>
                </Box>
              )}
            </Box>

            {/* Ï∞®Ìä∏ Ïª®Ìä∏Î°§ */}
            <ChartControls
              startDate={startDate}
              endDate={endDate}
              onStartDateChange={setStartDate}
              onEndDateChange={setEndDate}
              interval={interval}
              onIntervalChange={setInterval}
              isLoading={isLoading}
              chartType={chartType}
              onChartTypeChange={setChartType}
              adjusted={adjusted}
              onAdjustedChange={setAdjusted}
            />
          </Box>
        </Box>
      </Box>
    </LocalizationProvider>
  );
}
